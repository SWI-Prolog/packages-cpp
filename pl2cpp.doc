\documentclass[11pt,a4paper]{article}
\usepackage{times}
\usepackage{pl}
\usepackage{plpage}
%\usepackage{xpce}
\usepackage{html}
\sloppy

\onefile
\htmloutput{.}					% Output directory
\htmlmainfile{pl2cpp}				% Main document file
\bodycolor{white}				% Page colour

\renewcommand{\runningtitle}{A C++ interface to SWI-Prolog}

\makeindex

\begin{document}

\title{A C++ interface to SWI-Prolog (Version 2)}
\author{Jan Wielemaker \\
	VU University of Amsterdam \\
	The Netherlands \\
	E-mail: \email{jan@swi-prolog.org}}

\maketitle

\begin{abstract}
This document describes a C++ interface to SWI-Prolog. SWI-Prolog could
be used with C++ for a very long time, but only by calling the extern
"C" functions of the C-interface. The interface described herein
provides a true C++ layer around the C-interface for much more concise
and natural programming from C++. The interface deals with
type-conversion to and from native C data-types, transparent mapping of
exceptions, making queries to Prolog and registering foreign predicates.
\end{abstract}

\vfill

\vfill
\vfill

\newpage

\tableofcontents

\newpage

\section{Summary of changes between Versions 1 and 2}
\label{sec:summary-cpp-changes}

The overall structure of the API has been retained - that is,
it is a thin layer on top of the interface provided by
\file{SWI-Prolog.h}. Based on experience with the API,
most of the conversion operators have been removed or deprecated,
and replaced by "getter" methods. The overloaded constructors have
been replaced by subclasses for the various types.

More specifically:
\begin{itemize}
  \item
    The "cast" operators (e.g., \exam{(char*)t}) have been deprecated,
    replaced by "getters" (e.g., \exam{t.c_str()}).
  \item
    The overloaded assignment operator for unification is deprecated;
    replaced by unify_term(), unify_atom(), unify_term_ex(), unify_atom_ex(),
    etc.
  \item
    Various \exam{XXX_ex()} functions have been added, which check
    for failure and throw an exception.
  \item
    Type-checking methods have been added: type(), is_variable(), is_atom(), etc.
  \item
    More \exam{PL_...(term_t, ...)} methods have been added to \class{PlTerm}.
  \item
    \ctype{std::string} and \ctype{std::wstring} are now supported in most
    places where \ctype{char*} or \ctype{wchar_t*} are allowed.
  \item
    Most functions/methods that return an \ctype{int} for true/false now
    return a C++ \ctype{bool}.
  \item
    The wrapped C types (\ctype{term_t}, \ctype{atom_t}, etc.) have been
    made private - they can be accessed by the field \exam{C_}.
\end{itemize}

More details are given in \secref{cpp-changes}.

\section{Introduction}
\label{sec:cpp-intro}

C++ provides a number of features that make it possible to define a much
more natural and concise interface to dynamically typed languages than
plain C does. Using programmable type-conversion (\jargon{casting})
and overloading,
native data-types can be translated automatically into appropriate
Prolog types, automatic destructors can be used to deal with most of the
cleanup required and C++ exception handling can be used to map Prolog
exceptions and interface conversion errors to C++ exceptions, which are
automatically mapped to Prolog exceptions as control is turned back to
Prolog.

More information on the SWI-Prolog native types is given in
\secref{foreign-types}.

It would be tempting to use C++ conversion operators and method
overloading to automatically convert between C++ types such as
\ctype{std::string} and \ctype{int64_t} and Prolog foreign language
interface types such as \ctype{term_t} and \ctype{atom_t}. However,
types such as \ctype{term_t} are unsigned integers, so many of the
automatic type conversions can easily do something other than what the
programmer intended, resulting in subtle bugs that are difficult to
find. Therefore Version 2 of this interface reduces the amount of
automatic conversion and introduces some redundancy, to avoid these
subtle bugs, by using "getter" methods rather than conversion
operators, and using naming conventions for explicitly specifying
constructors.

\subsection*{Competing interfaces}

Volker Wysk has defined an alternative C++ mapping based on templates
and compatible to the STL framework.  See
\url{http://www.volker-wysk.de/swiprolog-c++/index.html}.


\subsection*{Acknowledgements}

I would like to thank Anjo Anjewierden for comments on the definition,
implementation and documentation of this package. Peter Ludemann
modified the interface to remove some pitfalls, and also to add
some convenience functions (see \secref{cpp-changes}).


\section{Overview}
\label{sec:cpp-overview}

The most useful area for exploiting C++ features is type-conversion.
Prolog variables are dynamically typed and all information is passed
around using the C-interface type \ctype{term_t}. In C++, \ctype{term_t}
is embedded in the \jargon{lightweight} class \class{PlTerm}.
Constructors and operator definitions provide flexible operations and
integration with important C-types (\ctype{char *}, \ctype{wchar_t*},
\ctype{long} and \ctype{double}), plus the C++-types (\ctype{std::string},
\ctype{std::wstring}).

The list below summarises the classes defined in the C++ interface.

\begin{description}
    \classitem{PlTerm}
Generic Prolog term that wraps \ctype{term_t}.
This is a "base class" whose constructor is
protected; subclasses specify the actual contents. Additional methods
allow checking the Prolog type, unification, comparison, conversion to
native C++-data types, etc. See \secref{cpp-plterm-casting}.

The subclass constructors are as follows. If a constructor fails
(e.g., out of memory), a \class{PlException} is thrown.
\begin{description}
    \classitem{PlTerm_atom}
Subclass of \class{PlTerm} with constructors for building
a term that contains an atom.
    \classitem{PlTerm_var}
Subclass of \class{PlTerm} with constructors for building
a term that contains an uninstantiated variable. Typically
this term is then unified with another object.
    \classitem{PlTerm_term_t}
Subclass of \class{PlTerm} with constructors for building
a term from a C \ctype{term_t}.
    \classitem{PlTerm_int}
Subclass of \class{PlTerm} with constructors for building
a term that contains a Prolog integer.
    \classitem{PlTerm_float}
Subclass of \class{PlTerm} with constructors for building
a term that contains a Prolog float.
    \classitem{PlTerm_pointer}
Subclass of \class{PlTerm} with constructors for building
a term that contains a raw pointer. This is mainly for
backwards compatibility; new code should use \jargon{blobs}.
    \classitem{PlTerm_string}
Subclass of \class{PlTerm} with constructors for building
a term that contains a Prolog string object.
    \classitem{PlTerm_list_codes}
Subclass of \class{PlTerm} with constructors for building
Prolog lists of character integer values.
    \classitem{PlTerm_chars}
Subclass of \class{PlTerm} with constructors for building
Prolog lists of one-character atoms (as atom_chars/2).
    \classitem{PlTerm_tail}
SubClass of \class{PlTerm} for building and analysing Prolog lists.
\end{description}

Additional subclasses of \class{PlTerm} are:
\begin{description}
    \classitem{PlCompound}
Subclass of \class{PlTerm} with constructors for building compound
terms. If there is a single string argument, then PL_chars_to_term()
or PL_wchars_to_term() is used to parse the string and create the
term. If the constructor has two arguments, the first is name of
a functor and the second is a \class{PlTermv} with the arguments.
    \classitem{PlTermv}
Vector of Prolog terms. See PL_new_term_refs(). The \const{[]} operator
is overloaded to access elements in this vector.  \class{PlTermv} is used
to build complex terms and provide argument-lists to Prolog goals.
    \classitem{PlException}
Subclass of \class{PlTerm} representing a Prolog exception.  Provides
methods for the Prolog communication and mapping to human-readable text
representation.
    \classitem{PlTypeError}
Subclass of \class{PlException} for representing a Prolog
\except{type_error} exception.
    \classitem{PlDomainError}
Subclass of \class{PlException} for representing a Prolog
\except{domain_error} exception.
    \classitem{PlExistenceError}
Subclass of \class{PlException} for representing a Prolog
\except{existence_error} exception.
    \classitem{PlPermissionError}
Subclass of \class{PlException} for representing a Prolog
\except{permission_error} exception.
\end{description}

    \classitem{PlAtom}
Allow for manipulating atoms (\ctype{atom_t}) in their internal Prolog representation
for fast comparison.
    \classitem{PlFunctor}
A wrapper for \class{functor_t}, which maps to the internal
representation of a name/arity pair.
    \classitem{PlQuery}
Represents opening and enumerating the solutions to a Prolog query.
    \classitem{PlFail}
Can be thrown to short-circuit processing and return failure to Prolog.
    \classitem{PlFrame}
This utility-class can be used to discard unused term-references as well
as to do `\jargon{data-backtracking}'.
    \classitem{PlEngine}
This class is used in \jargon{embedded} applications (applications
where the main control is held in C++).  It provides creation and
destruction of the Prolog environment.
    \classitem{PlRegister}
The encapsulation of PL_register_foreign() is defined to be able to
use C++ global constructors for registering foreign predicates.
\end{description}

The required C++ function header and registration of a predicate
is arranged through a macro called \cfuncref{PREDICATE}{}.

\subsection{Naming conventions, utility functions and methods}
\label{sec:cpp-naming}

The classes all have names starting with "Pl", using CamelCase;
this contrasts with the C functions that start with "PL_" and
use underscores.

The wrapper classes (\class{PlFunctor}, \class{PlAtom}, \class{PlTerm})
all contain a field \exam{C_} that contains the wrapped value
(\class{functor_t}, \class{atom_t}, \class{term_t} respectively).

The wrapper classes all define the following methods and constants:
\begin{itemize}
  \item
    default constructor (sets the wrapped value to \exam{null})
  \item
    constructor that takes the wrapped value (e.g.,
    for \class{PlAtom}, the constructor takes an \class{atom_t}
    value).
  \item
    \exam{C_} - the wrapped value
  \item
    \exam{null} - the null value (typically \exam{0})
  \item
    \exam{is_null()}, \exam{not_null()} - test
    for the wrapped value being \exam{null}.
  \item
    \exam{reset()} - set the wrapped value to \exam{null}
  \item
    \exam{reset(new_value)} - set the wrapped value
  \item
    The \class{bool} operator is turned off - use not_null() instead.
    (The reason: a \class{bool} conversion
    causes ambiguity with \exam{PlAtom(PlTterm)}
    and \exam{PlAtom(atom_t)})
\end{itemize}

The unification methods come in two flavours: one that returns a
\ctype{bool} (and gives a compile-time warning if the return value is
ignored) and one that checks the result and throws an exception on
failure. The methods that throw an exception end with "_ex", similar
to the existing functions like PL_get_atom_ex().

PlCheck() is a convenience function that can be used to call a C
function in \file{SWI-Prolog.h}. It checks the return code and throws
a \class{PlFail} exception on failure. The \cfuncref{PREDICATE}{} code
catches \class{PlFail} exceptions and converts them to the
\class{foreign_t} return code (\exam{TRUE} or \exam{FALSE}). If the
failure was called by an exception (that is, \exam{PL_exception(0)}
returns non-zero), the foreign function caller will detect that
situation and convert the failure to an exception.

The "getter" methods for \class{PlTerm} do not end with "_ex" -
they all throw an exception if the term isn't of the expected
Prolog type. Where possible, the "getters" have the same name
as the underlying type; but this isn't possible for types such
as \ctype{int} or \ctype{float}, so for these the name is
prepended with "get_".

"Getters" for integers have an additionnal problem, in that C++
doesn't define the sizes of \ctype{int} and \ctype{long}, nor for
\ctype{size_t}.  To get around this problem, there are overloaded
integer() methods that take a pointer; for example, this allows the
following code without knowing the exact definition of \ctype{size_t}:
\begin{code}
size_t sz;
t.integer(&sz);
\end{code}

There is an additional problem with characters - C promotes
them to \ctype{int} but C++ doesn't. In general, this shouldn't
cause any problems, but care must be used with the various
getters for integers.


\section{Examples}
\label{sec:cpp-examples}

Before going into a detailed description of the C++ classes we present
a few examples illustrating the `feel' of the interface.


\subsection{Hello(World)}
\label{sec:cpp-hello-world}

This simple example shows the basic definition of the predicate hello/1
and how a Prolog argument is converted to C-data:

\begin{code}
PREDICATE(hello, 1)
{ cout << "Hello " << A1.string() << endl;

  return true;
}
\end{code}

The arguments to PREDICATE() are the name and arity of the predicate.
The macros A<n> provide access to the predicate arguments by position
and are of the type \class{PlTerm}. The C or C++ string for a \class{PlTerm}
can be extracted using c_str(), wc_str(), string(), or wstring() methods;
and similar access methods provide an easy type-conversion
for most Prolog data-types, using the output of write/1 otherwise:

\begin{code}
?- hello(world).
Hello world

Yes
?- hello(X)
Hello _G170

X = _G170
\end{code}

\subsection{Adding numbers}
\label{sec:cpp-ex-adding-numbers}

This example shows arithmetic using the C++ interface, including
unification, type-checking, and conversion.  The predicate add/3 adds
the two first arguments and unifies the last with the result.

\begin{code}
PREDICATE(add, 3)
{ return A3.unify_integer(A1.get_long() + A2.get_long());
}
\end{code}

You can use your own variable names instead of \exam{A1},
\exam{A2}, etc.:

\begin{code}
PREDICATE(add, 3)  // add(+X, +Y, +Result)
{ PlTerm x(A1);
  PlTerm y(A2);
  PlTerm result(A3);
  return result.unify_integer(x.get_long() + y.get_long());
}
\end{code}


The get_long() method for a \class{PlTerm} performs a PL_get_long() and
throws a C++ exception if the Prolog argument is not a Prolog integer
or float that can be converted without loss to a \ctype{long}. The
unify_integer() method of \class{PlTerm} is defined to perform unification
and returns \const{true} or \const{false} depending on the result.
A similar unify_ex() method throws an exception if the unificaton fails
(and this exception becomes failure when control returns to Prolog).

\begin{code}
?- add(1, 2, X).

X = 3.
?- add(a, 2, X).
[ERROR: Type error: `integer' expected, found `a']
   Exception: (  7) add(a, 2, _G197) ?
\end{code}


\subsection{Average of solutions}
\label{sec:cpp-ex-average}

This example is a bit harder. The predicate average/3 is defined to take
the template \mbox{average(+Var, :Goal, -Average)}, where \arg{Goal}
binds \arg{Var} and will unify \arg{Average} with average of the
(integer) results.

\class{PlQuery} takes the name of a predicate and the goal-argument
vector as arguments. From this information it deduces the arity and
locates the predicate. The mehod next_solution() yields
\const{true} if there was a solution and \const{false} otherwise. If
the goal yields a Prolog exception, it is mapped into a C++ exception.


\begin{code}
PREDICATE(average, 3) /* average(+Templ, :Goal, -Average) */
{ long sum = 0;
  long n = 0;

  PlQuery q("call", PlTermv(A2));
  while( q.next_solution() )
  { sum += A1.get_long();
    n++;
  }
  return A3.unify_float(double(sum) / double(n));
}
\end{code}

\begin{code}
?- [user].
|: p(1).
|: p(10).
|: p(20).
|:
% user://1 compiled 0.00 sec, 3 clauses
true.

?- average(X, p(X), Average).
Average = 10.333333333333334.
\end{code}

\section{Rational for changes from version 1}
\label{sec:cpp-changes}

The original version of the C++ interface heavily used implicit
constructors and conversion operators. This allowed, for example:
\begin{code}
PREDICATE(hello, 1)
{ cout << "Hello " << (char *)A1 << endl;
  return true;
}

PREDICATE(add, 3)
{ return A3 = (long)A1 + (long)A2;
}
\end{code}

Version 2 is a bit more verbose:
\begin{code}
PREDICATE(hello, 1)
{ cout << "Hello " << A1.string() << endl;
  return true;
}

PREDICATE(add, 3)
{ return A3.unify_int(A1.get_long() + A2.get_long());
}
\end{code}

There are a few reasons for this:
\begin{itemize}
  \item
    The C-style of casts is deprecated in C++, so the expression
    \exam{(char *)A1} becomes the more verbose \exam{static_cast<char *>(A1)},
    which is longer than \exam{A1.string()}.
  \item
    The implicit constructors and conversion operators allowed
    directly calling the foreign language interface functions, for example:
    \begin{code}
    PlTerm t;
    Pl_put_atom_chars(t, "someName");
    \end{code}
    whereas this is now required:
    \begin{code}
    PlTerm t;
    Pl_put_atom_chars(t.get_term_t(), "someName");
    \end{code}
    However, this is mostly avoided by methods and constructors that
    wrap the foreign language functions:
    \begin{code}
    PlTerm_atom t("someName");
    \end{code}
    or
    \begin{code}
    auto t = PlTerm_atom("someName");
    \end{code}
  \item
    The implicit constructors and conversion operators, combined with
    the C++ conversion rules for integers and floats, could sometimes
    lead to subtle bugs that were difficult to find -- in one case, a
    typo resulted in terms being unified with floating point values when
    the code intended them to be atoms. This was mainly because the
    underlying C types for terms, atoms, etc. are unsigned integers,
    leading to confusion between numeric values and Prolog terms and
    atoms.
\item
    The overloaded assignment operator for unification changed the
    usual C++ semantics for assignments from returning a reference
    to the left-hand-side to returning a ctype{bool}. In addition,
    the result of unification should always be checked (e.g., an
    "always succeed" unification could fail due to an out-of-memory
    error), so it's useful to have both unify_XXX() methods that return
    a ctype{bool} and unify_XXX_ex() methods that throw an exception
    on unification failure.
\end{itemize}

Over time, it is expected that some of these restrictions will be
eased, to allow a more compact coding style that was the intent of the
original API. However, too much use of overloaded
methods/constructors, implicit conversions and constructors can result
in code that's difficult to understand, so a balance needs to be
struck between compactness of code and understandability.

For backwards compatibility, some of the version 1 interface is still
available (except for the implicit constructors and operators), but
marked as "deprecated"; code that depends on the parts that have been
removed can be easily changed to use the new interface.

\section{The class PlFail}
\label{sec:cpp-plfail}

The \class{PlFail} class is used for short-circuiting a function when
failure or an exception occurs. For example, this code:
\begin{code}
  bool
  some_function(PlTerm t)
  { if ( !PL_put_integer(t.C_, 0) )
      return false;
    return true;
  }
\end{code}
can be written
\begin{code}
  void
  some_function(PlTerm t)
  { PlCheck(PL_put_integer(t.C_, 0));
  }
\end{code}
and any errors will be handled in the code generated by
the \cfuncref{PREDICATE}{} macro.

In general, wherever there is a method that wraps a C "PL_"
function, \cfuncref{PlCheck}{} is used, e.g.:


\section{The class PlTerm}
\label{sec:cpp-plterm}

As we have seen from the examples, the \class{PlTerm} class plays a
central role in conversion and operating on Prolog data. This section
provides complete documentation of this class.

\subsection{Constructors}
\label{sec:cpp-plterm-constructurs}

The constructors are defined as subclasses of \class{PlTerm}, with
a name that reflects the Prolog type of what is being created
(e.g., \class{PlTerm_atom} creates an atom; \class{PlTerm_string}
creates a Prolog string).
All of the constructors are
"explicit" because implicit creation of \class{PlTerm} objects can lead
to subtle and difficult to debug errors.

\begin{description}
    \constructor{PlTerm}{}
Creates a new initialised "null" term (holding a Prolog variable).
    \constructor{PlTerm_term_t}{term_t t}
Converts between the C-interface and the C++ interface by turning the
term-reference into an instance of \class{PlTerm}.  Note that, being a
lightweight class, this is a no-op at the machine-level!
    \constructor{PlTerm_atom}{const char *text}
Creates a term-references holding a Prolog atom representing \arg{text}.
    \constructor{PlTerm_atom}{const wchar_t *text}
Creates a term-references holding a Prolog atom representing \arg{text}.
    \constructor{PlTerm_atom}{const PlAtom \&atom}
Creates a term-references holding a Prolog atom from an atom-handle.
    \constructor{PlTerm_int}{long n}
Creates a term-references holding a Prolog integer representing \arg{n}.
    \constructor{PlTerm_int}{int64_t n}
Creates a term-references holding a Prolog integer representing \arg{n} (up to 64 bits signed).
    \constructor{PlTerm_int}{uint64_t n}
Creates a term-references holding a Prolog integer representing \arg{n} (up to 64 bits unsigned).
    \constructor{PlTerm_float}{double f}
Creates a term-references holding a Prolog float representing \arg{f}.
    \constructor{PlTerm_pointer}{void *ptr}
Creates a term-references holding a Prolog pointer.  A pointer is
represented in Prolog as a mangled integer.  The mangling is designed
to make most pointers fit into a \jargon{tagged-integer}.  Any valid
pointer can be represented.  This mechanism can be used to represent
pointers to C++ objects in Prolog.  Please note that `MyClass' should
define conversion to and from \ctype{void *}.
Also note that in general \jargon{blobs} are a better way of doing this
(see the section on \jargon{blobs} in the Foreign Language Interface
part of the SWI-Prolog manual).

\begin{code}
PREDICATE(make_my_object, 1)
{ auto myobj = new MyClass();

  return A1.unify_pointer(myobj);
}

PREDICATE(my_object_contents, 2)
{ auto myobj = static_cast<MyClass*>(A1.pointer());
  return A2.unify_string(myobj->contents);
}

PREDICATE(free_my_object, 1)
{ auto myobj = static_cast<MyClass*>(A1.pointer());

  delete myobj;
  return true;
}
\end{code}
\end{description}


\subsection{Converting PlTerm to native C and C++ types}
\label{sec:cpp-plterm-casting}

\class{PlTerm} can be converted to the following types:

\begin{description}
    \cppcast{PlTerm}{term_t}
This cast is used for integration with the C-interface primitives.
    \cppcast{PlTerm}{long}
Yields a \ctype{long} if the \class{PlTerm} is a Prolog integer or
float that can be converted without loss to a long.  throws a
\except{type_error} exception otherwise.
    \cppcast{PlTerm}{int}
Same as for \ctype{long}, but might represent fewer bits.
    \cppcast{PlTerm}{double}
Yields the value as a C double if \class{PlTerm} represents a
Prolog integer or float.
    \cppcast{PlTerm}{wchar_t *}
    \nodescription
    \cppcast{PlTerm}{char *}
Converts the Prolog argument using PL_get_chars() using the flags
\const{CVT_ALL|CVT_WRITE|BUF_RING}, which implies Prolog atoms and
strings are converted to the represented text.  All other data is
handed to write/1.  If the text is static in Prolog, a direct pointer
to the string is returned.  Otherwise the text is saved in a ring of
16 buffers and must be copied to avoid overwriting.
    \cppcast{PlTerm}{void *}
Extracts pointer value from a term. The term should have been created
by PlTerm::PlTerm(void*).
\end{description}

In addition, the Prolog type (`PL_VARIABLE`, `PL_ATOM`, ... `PL_DICT`
can be determined using the type() method. There are also boolean
methods that check the type:
\begin{description}
  \cfunction{int}{type}{} See PL_term_type()
  \cfunction{bool}{is_variable}{}  See PL_is_variable()
  \cfunction{bool}{is_ground}{} See PL_is_ground()
  \cfunction{bool}{is_atom} See PL_is_atom()
  \cfunction{bool}{is_integer} See PL_is_integer()
  \cfunction{bool}{is_string} See PL_is_string()
  \cfunction{bool}{is_float} See PL_is_float()
  \cfunction{bool}{is_rational} See PL_is_rational()
  \cfunction{bool}{is_compound} See PL_is_compound()
  \cfunction{bool}{is_callable} See PL_is_callable()
  \cfunction{bool}{is_list} See PL_is_list()
  \cfunction{bool}{is_dict} See PL_is_dict()
  \cfunction{bool}{is_pair} See PL_is_pair()
  \cfunction{bool}{is_atomic} See PL_is_atomic()
  \cfunction{bool}{is_number} See PL_is_number()
  \cfunction{bool}{is_acyclic} See PL_is_acyclic()
  \cfunction{bool}{is_functor}{PlFunctor} See PL_is_functor()
\end{description}

\subsection{Unification}
\label{sec:cpp-plterm-unification}

\begin{description}
    \cfunction{bool}{PlTerm::unify_term}{PlTerm}
    \nodescription
    \cfunction{bool}{PlTerm::unify_atom}{PlAtom}
    \nodescription
    \cfunction{bool}{PlTerm::unify_atom}{string}
    \nodescription
    \cfunction{bool}{PlTerm::unify_list_codes}{string}
    \nodescription
    \cfunction{bool}{PlTerm::unify_list_chars}{string}
    \nodescription
    \cfunction{bool}{PlTerm::unify_integer}{int}
    \nodescription
    \cfunction{bool}{PlTerm::unify_float}{double}
    \nodescription
    \cfunction{bool}{PlTerm::unify_string}{string}
    \nodescription
    \cfunction{bool}{PlTerm::unify_functor}{PlFunctor}
    \nodescription
    \cfunction{bool}{PlTerm::unify_pointer}{void *}
    \nodescription
    \cfunction{bool}{PlTerm::unify_nil}{}
    \nodescription
    \cfunction{bool}{PlTerm::unify_blob}{void *blob, size_t len, PL_blob_t *type}
    \nodescription
    \cfunction{bool}{PlTerm::unify_chars}{int flags, size_t len, const char *s}

A family of unification methods are defined for the various Prolog types and
C++ types. Wherever \ctype{string} is shown, you can use:
\begin{itemize}
  \item \ctype{char*}
  \item \ctype{whar_t*}
  \item \ctype{std::string}
  \item \ctype{std::wstring}
\end{itemize}

\end{description}

\begin{description}
    \cfunction{void}{PlTerm::unify_term_ex}{PlTerm}
    \nodescription
    \cfunction{void}{PlTerm::unify_atom_ex}{PlAtom}
    \nodescription
    \cfunction{void}{PlTerm::unify_atom_ex}{string}
    \nodescription
    \cfunction{void}{PlTerm::unify_list_codes_ex}{string}
    \nodescription
    \cfunction{void}{PlTerm::unify_list_chars_ex}{string}
    \nodescription
    \cfunction{void}{PlTerm::unify_integer_ex}{int}
    \nodescription
    \cfunction{void}{PlTerm::unify_float_ex}{double}
    \nodescription
    \cfunction{void}{PlTerm::unify_string_ex}{string}
    \nodescription
    \cfunction{void}{PlTerm::unify_functor_ex}{PlFunctor}
    \nodescription
    \cfunction{void}{PlTerm::unify_pointer_ex}{void *}
    \nodescription
    \cfunction{void}{PlTerm::unify_nil_ex}{}
    \nodescription
    \cfunction{void}{PlTerm::unify_blob_ex}{void *blob, size_t len, PL_blob_t *type}
    \nodescription
    \cfunction{void}{PlTerm::unify_chars_ex}{int flags, size_t len, const char *s}

Each of the unification methods has a corresponding method that ends with "_ex",
which does the unification and throws \ctype{PlFail} on failure.

\end{description}

Here is an example:
\begin{code}
PREDICATE(hostname, 1)
{ char buf[256];
  if ( gethostname(buf, sizeof buf) == 0 )
    return A1.unify_atom(buf);
  return false;
}
\end{code}
An alternative way of writing this would use the \class{PlFail} exception and
the "_ex" form of the unification method. In this particular case, the code is
more verbose; but for more complex foreign predicates, this style results in
less verbose code.
\begin{code}
PREDICATE(hostname2, 1)
{ char buf[256];
  if ( gethostname(buf, sizeof buf) != 0 )
    throw PlFail();
  A1.unify_atom_ex(buf);
  return true;
}
\end{code}


\subsection{Comparison}
\label{sec:cpp-plterm-comparison}

\begin{description}
    \cfunction{int}{PlTerm::compare}{const PlTerm& t2}
    \nodescription
    \cfunction{bool}{PlTerm::operator ==}{const PlTerm \&t}
    \nodescription
    \cfunction{bool}{PlTerm::operator !=}{const PlTerm \&t}
    \nodescription
    \cfunction{bool}{PlTerm::operator $<$}{const PlTerm \&t}
    \nodescription
    \cfunction{bool}{PlTerm::operator $>$}{const PlTerm \&t}
    \nodescription
    \cfunction{bool}{PlTerm::operator $<=$}{const PlTerm \&t}
    \nodescription
    \cfunction{bool}{PlTerm::operator $>=$}{const PlTerm \&t}
Compare the instance with \arg{t} and return the result according to
the Prolog defined \jargon{standard order of terms}.
    \cfunction{bool}{PlTerm::operator ==}{long num}
    \nodescription
    \cfunction{bool}{PlTerm::operator !=}{long num}
    \nodescription
    \cfunction{bool}{PlTerm::operator $<$}{long num}
    \nodescription
    \cfunction{bool}{PlTerm::operator $>$}{long num}
    \nodescription
    \cfunction{bool}{PlTerm::operator $<=$}{long num}
    \nodescription
    \cfunction{bool}{PlTerm::operator $>=$}{long num}
Convert \class{PlTerm} to a \ctype{long} and perform standard
C-comparison between the two long integers. If \class{PlTerm} cannot be
converted a \except{type_error} is raised.

    \cfunction{bool}{PlTerm::operator ==}{const wchar_t *}
    \nodescription
    \cfunction{bool}{PlTerm::operator ==}{const char *}
    \nodescription
    \cfunction{bool}{PlTerm::operator ==}{std::wstring}
    \nodescription
    \cfunction{bool}{PlTerm::operator ==}{std::string}
Yields \const{true} if the \class{PlTerm} is an atom or string
representing the same text as the argument, \const{false} if the
conversion was successful, but the strings are not equal and an
\except{type_error} exception if the conversion failed.
\end{description}

Below are some typical examples.  See \secref{dirplatom} for direct
manipulation of atoms in their internal representation.

\begin{center}
\begin{tabularlp}{\tt A1 == PlCompound("a(1)")}
\hline
\tt A1 $<$ 0	& Test \arg{A1} to hold a Prolog integer or float
		  that can be transformed lossless to an integer
		  less than zero. \\
\tt A1 $<$ PlTerm(0) &
		  \arg{A1} is before the term `0' in the `standard
		  order of terms'. This means that if \arg{A1}
		  represents an atom, this test yields \const{true}. \\
\tt A1 == PlCompound("a(1)") &
		  Test \arg{A1} to represent the term
		  \exam{a(1)}. \\
\tt A1 == "now" &
		  Test \arg{A1} to be an atom or string holding the
		  text ``now''. \\
\hline
\end{tabularlp}
\end{center}


\subsection{Analysing compound terms}
\label{sec:cpp-plterm-compound}

Compound terms can be viewed as an array of terms with a name and arity
(length). This view is expressed by overloading the \const{[]} operator.

A \except{type_error} is raised if the argument is not compound and a
\except{domain_error} if the index is out of range.

In addition, the following functions are defined:

\begin{description}
    \cfunction{PlTerm}{PlTerm::operator []}{int arg}
If the \class{PlTerm} is a compound term and \arg{arg} is between 1 and
the arity of the term, return a new \class{PlTerm} representing the
arg-th argument of the term. If \class{PlTerm} is not compound, a
\except{type_error} is raised. Id \arg{arg} is out of range, a
\except{domain_error} is raised. Please note the counting from 1 which
is consistent to Prolog's arg/3 predicate, but inconsistent to C's
normal view on an array. See also class \class{PlCompound}. The
following example tests \arg{x} to represent a term with first-argument
an atom or string equal to \exam{gnat}.

\begin{code}
   ...,
   if ( x[1] == "gnat" )
     ...
\end{code}

    \cfunction{const char *}{PlTerm::name}{}
Return a \ctype{const char *} holding the name of the functor of the
compound term.  Raises a \except{type_error} if the argument is not
compound.
    \cfunction{size_t}{PlTerm::arity}{}
Returns the arity of the compound term. Raises a \except{type_error} if
the argument is not compound.
\end{description}

\subsection{Miscellaneous}
\label{sec:cpp-plterm-misc}

\begin{description}
    \cfunction{bool}{is_null}{}
       \exam{t.is_null()} is the same as \exam{t.C_ == PlTerm::null}
    \cfunction{bool}{not_null}{}
       \exam{t.not_null()} is the same as \exam{t.C_ != PlTerm::null}
    \cfunction{bool}{reset}{}
       \exam{t.reset()} is the same as \exam{t.C_ = PlTerm::null}
    \cfunction{bool}{reset}{term_t}
       \exam{t.reset(x)} is the same as \exam{t.C_ = x}
    \cfunction{int}{PlTerm::type}{}
Yields the actual type of the term as PL_term_type(). Return values are
\const{PL_VARIABLE}, \const{PL_FLOAT}, \const{PL_INTEGER},
\const{PL_ATOM}, \const{PL_STRING} or \const{PL_TERM}
\end{description}

To avoid very confusing combinations of constructors and therefore
possible undesirable effects a number of subclasses of \class{PlTerm}
have been defined that provide constructors for creating special Prolog
terms.  These subclasses are defined below.

\subsection{The class PlTermString}
\label{sec:cpp-plstring}

A SWI-Prolog string represents a byte-string on the global stack.  Its
lifetime is the same as for compound terms and other data living on
the global stack.  Strings are not only a compound representation of
text that is garbage-collected, but as they can contain 0-bytes, they
can be used to contain arbitrary C-data structures. However, it is
generally preferred to use blobs for storing arbitrary C-data structures
(see also \exam{PlTerm_pointer(void *ptr)}).


\begin{description}
    \constructor{PlString}{const wchar_t *text}
    \nodescription
    \constructor{PlString}{const char *text}
Create a SWI-Prolog string object from a 0-terminated C-string.  The
\arg{text} is copied.

    \constructor{PlString}{const wchar_t *text, size_t len}
    \nodescription
    \constructor{PlString}{const char *text, size_t len}
Create a SWI-Prolog string object from a C-string with specified length.
The \arg{text} may contain 0-characters and is copied.
\end{description}

\subsection{The class PlCodeList}
\label{sec:cpp-codelist}

\begin{description}
    \constructor{PlCodeList}{const wchar_t *text}
    \nodescription
    \constructor{PlCodeList}{const char *text}
Create a Prolog list of ASCII codes from a 0-terminated C-string.
\end{description}


\subsection{The class PlCharList}
\label{sec:cpp-plcharlist}

Character lists are compliant to Prolog's atom_chars/2 predicate.

\begin{description}
    \constructor{PlCharList}{const wchar_t *text}
    \nodescription
    \constructor{PlCharList}{const char *text}
Create a Prolog list of one-character atoms from a 0-terminated
C-string.
\end{description}


\subsection{The class PlCompound}
\label{sec:cpp-plcompound}

\begin{description}
    \constructor{PlCompound}{const wchar_t *text}
    \nodescription
    \constructor{PlCompound}{const char *text}
Create a term by parsing (as read/1) the \arg{text}.  If the \arg{text}
is not valid Prolog syntax, a \except{syntax_error} exception is raised.
Otherwise a new term-reference holding the parsed text is created.

    \constructor{PlCompound}{const wchar_t *functor, PlTermv args}
    \nodescription
    \constructor{PlCompound}{const char *functor, PlTermv args}
Create a compound term with the given name from the given vector of
arguments.  See \class{PlTermv} for details.  The example below
creates the Prolog term \exam{hello(world)}.

\begin{code}
PlCompound("hello", PlTermv("world"))
\end{code}
\end{description}


\subsection{The class PlTail}		\label{sec:pltail}

The class \class{PlTail} is both for analysing and constructing lists.
It is called \class{PlTail} as enumeration-steps make the term-reference
follow the `tail' of the list.

\begin{description}
    \constructor{PlTail}{PlTerm list}
A \class{PlTail} is created by making a new term-reference pointing to
the same object.  As \class{PlTail} is used to enumerate or build a
Prolog list, the initial \arg{list} term-reference keeps pointing to
the head of the list.
    \cfunction{int}{PlTail::append}{const PlTerm \&element}
Appends \arg{element} to the list and make the \class{PlTail} reference
point to the new variable tail.  If \arg{A} is a variable, and this
function is called on it using the argument \exam{"gnat"}, a list of
the form \exam{[gnat|B]} is created and the \class{PlTail} object
now points to the new variable \arg{B}.

This function returns \const{true} if the unification succeeded and
\const{false} otherwise.  No exceptions are generated.

The example below translates the main() argument vector to Prolog and
calls the prolog predicate entry/1 with it.

\begin{code}
int
main(int argc, char **argv)
{ PlEngine e(argv[0]);
  PlTermv av(1);
  PlTail l(av[0]);

  for(int i=0; i<argc; i++)
    l.append(argv[i]);
  l.close();

  PlQuery q("entry", av);
  return q.next_solution() ? 0 : 1;
}
\end{code}
    \cfunction{int}{PlTail::close}{}
Unifies the term with \const{[]} and returns the result of the
unification.
    \cfunction{int}{PlTail::next}{PlTerm \&t}
Bind \arg{t} to the next element of the list \class{PlTail} and advance
\class{PlTail}. Returns \const{true} on success and \const{false} if
\class{PlTail} represents the empty list. If \class{PlTail} is neither a
list nor the empty list, a \except{type_error} is thrown. The example
below prints the elements of a list.

\begin{code}
PREDICATE(write_list, 1)
{ PlTail tail(A1);
  PlTerm e;

  while(tail.next(e))
    cout << (char *)e << endl;

  return true;
}
\end{code}
\end{description}


\section{The class PlTermv}
\label{sec:cpp-pltermv}

The class \class{PlTermv} represents an array of term-references.  This
type is used to pass the arguments to a foreignly defined predicate,
construct compound terms (see \cfuncref{PlTerm::PlTerm}{const char *name,
PlTermv arguments}) and to create queries (see \class{PlQuery}).

The only useful member function is the overloading of \const{[]},
providing (0-based) access to the elements.  Range checking is performed
and raises a \except{domain_error} exception.

The constructors for this class are below.

\begin{description}
    \constructor{PlTermv}{int size}
Create a new array of term-references, all holding variables.
    \constructor{PlTermv}{int size, term_t t0}
Convert a C-interface defined term-array into an instance.
    \constructor{PlTermv}{PlTerm ...}
Create a vector from 1 to 5 initialising arguments.  For example:

\begin{code}
load_file(const char *file)
{ return PlCall("compile", PlTermv(file));
}
\end{code}

If the vector has to contain more than 5 elements, the following
construction should be used:

\begin{code}
{ PlTermv av(10);

  av[0] = "hello";
  ...
\end{code}
\end{description}


\section{The class PlAtom - Supporting Prolog constants}
\label{sec:cpp-prolog-constants}

Both for quick comparison as for quick building of lists of atoms, it
is desirable to provide access to Prolog's atom-table, mapping handles
to unique string-constants.  If the handles of two atoms are different
it is guaranteed they represent different text strings.

Suppose we want to test whether a term represents a certain atom, this
interface presents a large number of alternatives:

\subsection*{Direct comparision to char *}

Example:

\begin{code}
PREDICATE(test, 1)
{ if ( A1 == "read" )
    ...;
\end{code}

This writes easily and is the preferred method is performance is not
critical and only a few comparisons have to be made. It validates
\arg{A1} to be a term-reference representing text (atom, string, integer
or float) extracts the represented text and uses strcmp() to match the
strings.

\subsection*{Direct comparision to PlAtom}		\label{sec:dirplatom}

Example:

\begin{code}
static PlAtom ATOM_read("read");

PREDICATE(test, 1)
{ if ( A1 == ATOM_read )
    ...;
\end{code}

This case raises a \except{type_error} if \arg{A1} is not an atom.
Otherwise it extacts the atom-handle and compares it to the atom-handle
of the global \class{PlAtom} object. This approach is faster and
provides more strict type-checking.

\subsection*{Extraction of the atom and comparison to PlAtom}

Example:

\begin{code}
static PlAtom ATOM_read("read");

PREDICATE(test, 1)
{ PlAtom a1(A1);

  if ( a1 == ATOM_read )
    ...;
\end{code}

This approach is basically the same as \secref{dirplatom}, but in
nested if-then-else the extraction of the atom from the term is
done only once.

\subsection*{Extraction of the atom and comparison to char *}

Example:

\begin{code}
PREDICATE(test, 1)
{ PlAtom a1(A1);

  if ( a1 == "read" )
    ...;
\end{code}

This approach extracts the atom once and for each test extracts
the represented string from the atom and compares it.  It avoids
the need for global atom constructors.

\begin{description}
    \constructor{PlAtom}{atom_t handle}
Create from C-interface atom handle (\ctype{atom_t}.  Used internally and for
integration with the C-interface.
    \constructor{PlAtom}{const char_t *text}
    \nodescription
    \constructor{PlAtom}{const wchar *text}
    \nodescription
    \constructor{PlAtom}{const std::string\& text}
    \nodescription
    \constructor{PlAtom}{const std::wstring\& text}
Create an atom from a string.  The \arg{text} is copied if a new atom
is created. See PL_new_atom(), PL_new_atom_wchars(),
PL_new_atom_nchars(), PL_new_atom_wchars().
    \constructor{PlAtom}{const PlTerm \&t}
If \arg{t} represents an atom, the new instance represents this
atom.  Otherwise a \except{type_error} is thrown.
    \cfunction{int}{PlAtom::operator ==}{const wchar_t *text}
    \nodescription
    \cfunction{int}{PlAtom::operator ==}{const char *text}
    \nodescription
    \cfunction{int}{PlAtom::operator ==}{const std::string\& text}
    \nodescription
    \cfunction{int}{PlAtom::operator ==}{const std::wstring\& text}
Yields \const{true} if the atom represents \arg{text}, \const{false}
otherwise.  Performs a strcmp() or similar for this.
    \cfunction{int}{PlAtom::operator ==}{const PlAtom \&a}
Compares the two atom-handles, returning \const{true} or
\const{false}. Because atoms are unique, there is no need
to use strcmp() for this.
    \cfunction{int}{PlAtom::operator !=}{const wchar_t *text}
    \nodescription
    \cfunction{int}{PlAtom::operator !=}{const char *text}
    \nodescription
    \cfunction{int}{PlAtom::operator !=}{const std::string\& text}
    \nodescription
    \cfunction{int}{PlAtom::operator !=}{const std::wstring\& text}
    \nodescription
    \cfunction{int}{PlAtom::operator !=}{const PlAtom \&a}
The inverse of the \exam{==} operator.
    \cfunction{bool}{is_valid}{}
Verifies that the handle is valid. This can be used after calling
a function that returns an atom handle, to check that a new atom
was created.
    \cfunction{void}{reset}{}
Sets the handle to an invalid valid - a subsequent call to is_valid()
will return \const{false}.
    \cfunction{const char*}{c_str}{}
    \nodescription
    \cfunction{const wchar_t*}{wc_str}{}
    \nodescription
    \cfunction{const std:string}{string}{}
    \nodescription
    \cfunction{const std:string}{wstring}{}
Returns the string representation of the atom. This does not
quote or escape any characters that would need to be escaped
if the atom were to be input to the Prolog parser.
    \cfunction{void}{register_atom}{}
See PL_register_atom().
    \cfunction{void}{unregister_atom}{}
See PL_unregister_atom().
    \cfunction{void*}{blob_data}{size_t *len, struct PL_blob_t **type}
See PL_blob_data().
\end{description}


\section{The class PlRegister}
\label{sec:cpp-plregister}

This class encapsulates PL_register_foreign().  It is defined as a class
rather then a function to exploit the C++ \jargon{global constructor}
feature.  This class provides a constructor to deal with the PREDICATE()
way of defining foreign predicates as well as constructors to deal with
more conventional foreign predicate definitions.

\begin{description}
    \constructor{PlRegister}{const char *module,
			     const char *name,
			     int arity,
			     foreign_t (f)(term_t t0, int a, control_t ctx)}
Register \arg{f} as a the implementation of the foreign predicate
<name>/<arity>.  This interface uses the \const{PL_FA_VARARGS} calling
convention, where the argument list of the predicate is passed using an
array of \ctype{term_t} objects as returned by PL_new_term_refs().  This
interface poses no limits on the arity of the predicate and is faster,
especially for a large number of arguments.
    \constructor{PlRegister}{const char *module,
			     const char *name,
			     foreign_t (*f)(PlTerm a0, \ldots)}
Registers functions for use with the traditional calling conventional,
where each positional argument to the predicate is passed as an argument
to the function \arg{f}. This can be used to define functions as
predicates similar to what is used in the C-interface:

\begin{code}
static foreign_t
pl_hello(PlTerm a1)
{ ...
}

PlRegister x_hello_1(NULL, "hello", 1, pl_hello);
\end{code}

This construct is currently supported upto 3 arguments.
\end{description}


\section{The class PlQuery}
\label{sec:cpp-plquery}

This class encapsulates the call-backs onto Prolog.

\begin{description}
    \constructor{PlQuery}{const char *name, const PlTermv \&av}
Create a query where \arg{name} defines the name of the predicate and
\arg{av} the argument vector.  The arity is deduced from \arg{av}.  The
predicate is located in the Prolog module \module{user}.
    \constructor{PlQuery}{const char *module, const char *name,
			  const PlTermv \&av}
Same, but performs the predicate lookup in the indicated module.
    \cfunction{int}{PlQuery::next_solution}{}
Provide the next solution to the query.  Yields \const{true} if
successful and \const{false} if there are no (more) solutions.
Prolog exceptions are mapped to C++ exceptions.
\end{description}

Below is an example listing the currently defined Prolog modules
to the terminal.

\begin{code}
PREDICATE(list_modules, 0)
{ PlTermv av(1);

  PlQuery q("current_module", av);
  while( q.next_solution() )
    cout << (char *)av[0] << endl;

  return true;
}
\end{code}

In addition to the above, the following functions have been defined.

\begin{description}
    \cfunction{int}{PlCall}{const char *predicate, const PlTermv \&av}
Creates a \class{PlQuery} from the arguments generates the
first next_solution() and destroys the query.  Returns the
result of next_solution() or an exception.
    \cfunction{int}{PlCall}{const char *module, const char *predicate,
			    const PlTermv \&av}
Same, locating the predicate in the named module.
    \cfunction{int}{PlCall}{const wchar_t *goal}
    \nodescription
    \cfunction{int}{PlCall}{const char *goal}
Translates \arg{goal} into a term and calls this term as the other
PlCall() variations. Especially suitable for simple goals such as making
Prolog load a file.
\end{description}

\subsection{The class PlFrame}
\label{sec:cpp-plframe}

The class \class{PlFrame} provides an interface to discard unused
term-references as well as rewinding unifications
(\jargon{data-backtracking}). Reclaiming unused term-references is
automatically performed after a call to a C++-defined predicate has
finished and returns control to Prolog. In this scenario \class{PlFrame}
is rarely of any use. This class comes into play if the toplevel program
is defined in C++ and calls Prolog multiple times.  Setting up arguments
to a query requires term-references and using \class{PlFrame} is the
only way to reclaim them.

\begin{description}
    \constructor{PlFrame}{}
Creating an instance of this class marks all term-references created
afterwards to be valid only in the scope of this instance.
    \destructor{PlFrame}
Reclaims all term-references created after constructing the instance.
    \cfunction{void}{PlFrame::rewind}{}
Discards all term-references {\bf and} global-stack data created as well
as undoing all unifications after the instance was created.
\end{description}

\index{assert}%
A typical use for \class{PlFrame} is the definition of C++ functions
that call Prolog and may be called repeatedly from C++.  Consider the
definition of assertWord(), adding a fact to word/1:

\begin{code}
void
assertWord(const char *word)
{ PlFrame fr;
  PlTermv av(1);

  av[0] = PlCompound("word", PlTermv(word));
  PlQuery q("assert", av);
  q.next_solution();
}
\end{code}


This example shows the most sensible use of \class{PlFrame} if it is
used in the context of a foreign predicate. The predicate's thruth-value
is the same as for the Prolog unification (=/2), but has no
side effects. In Prolog one would use double negation to achieve this.

\begin{code}
PREDICATE(can_unify, 2)
{ PlFrame fr;

  int rval = (A1=A2);
  fr.rewind();
  return rval;
}
\end{code}

\section{The PREDICATE macro}
\label{sec:cpp-predicate-macro}

The PREDICATE macro is there to make your code look nice, taking care of
the interface to the C-defined SWI-Prolog kernel as well as mapping
exceptions.  Using the macro

\begin{code}
PREDICATE(hello, 1)
\end{code}

is the same as writing:

\begin{code}
static foreign_t pl_hello__1(PlTermv PL_av);

static foreign_t
_pl_hello__1(term_t t0, int arity, control_t ctx)
{ (void)arity; (void)ctx;
  try
  { return pl_hello__1(PlTermv(1, t0));
  } catch ( PlException& ex )
  { return ex.plThrow();
  }
}

static PlRegister _x_hello__1("hello", 1, _pl_hello__1);

static foreign_t
pl_hello__1(PlTermv PL_av)
\end{code}

The first function converts the parameters passed from the Prolog
kernel to a \class{PlTermv} instance and maps exceptions raised in
the body to Prolog exceptions.  The \class{PlRegister} global
constructor registers the predicate.  Finally, the function header
for the implementation is created.

\subsection{Variations of the PREDICATE macro}
\label{sec:cpp-predicate-macro-variations}

The PREDICATE() macros has a number of variations that deal with
special cases.

\begin{description}
    \cmacro{}{PREDICATE0}{name}
This is the same as PREDICATE(name, 0).  It avoids a compiler warning
about that \const{PL_av} is not used.

    \cmacro{}{NAMED_PREDICATE}{plname, cname, arity}
This version can be used to create predicates whose name is not a valid
C++ identifier. Here is a ---hypothetical--- example, which unifies the
second argument with a stringified version of the first. The `cname' is
used to create a name for the functions. The concrete name does not
matter, but must be unique. Typically it is a descriptive name using the
limitations imposed by C++ indentifiers.

    \begin{code}
    NAMED_PREDICATE("#", hash, 2)
    { A2 = (wchar_t*)A1;
    }
    \end{code}

    \cmacro{}{NAMED_PREDICATE_NONDET}{plname, cname, arity}
Define a non-deterministic Prolog predicate in C++. See
\file{SWI-cpp.h}.  FIXME: Needs cleanup and an example.
\end{description}


\subsection{Controlling the Prolog destination module}
\label{sec:cpp-module}

With no special precautions, the predicates are defined into the
module from which load_foreign_library/1 was called, or in the module
\const{user} if there is no Prolog context from which to deduce the
module such as while linking the extension statically with the Prolog
kernel.

Alternatively, {\em before} loading the SWI-Prolog include file, the
macro PROLOG_MODULE may be defined to a string containing the name of
the destination module. A module name may only contain alpha-numerical
characters (letters, digits, _).  See the example below:

\begin{code}
#define PROLOG_MODULE "math"
#include <SWI-Prolog.h>
#include <math.h>

PREDICATE(pi, 1)
{ A1 = M_PI;
}
\end{code}

\begin{code}
?- math:pi(X).

X = 3.14159
\end{code}


\section{Exceptions}
\label{sec:cpp-exceptions}

Prolog exceptions are mapped to C++ exceptions using the subclass
\class{PlException} of \class{PlTerm} to represent the Prolog exception
term. All type-conversion functions of the interface raise
Prolog-compliant exceptions, providing decent error-handling support at
no extra work for the programmer.

For some commonly used exceptions, subclasses of \class{PlException}
have been created to exploit both their constructors for easy creation
of these exceptions as well as selective trapping in C++.  Currently,
these are \class{PlTypeEror} and \class{PlDomainError}.

To throw an exception, create an instance of \class{PlException} and
use throw() or PlException::cppThrow().  The latter refines the C++
exception class according to the represented Prolog exception before
calling throw().

\begin{code}
  char *data = "users";

  throw PlException(PlCompound("no_database", PlTerm(data)));
\end{code}

\subsection{The class PlException}
\label{sec:cpp-plexception}

This subclass of \class{PlTerm} is used to represent exceptions.
Currently defined methods are:

\begin{description}
    \constructor{PlException}{const PlTerm \&t}
Create an exception from a general Prolog term.  This is provides the
interface for throwing any Prolog terms as an exception.
    \cppcast{PlException}{wchar_t *}
    \nodescription
    \cppcast{PlException}{char *}
The exception is translated into a message as produced by
print_message/2.  The character data is stored in a ring.  Example:

\begin{code}
  ...;
  try
  { PlCall("consult(load)");
  } catch ( PlException& ex )
  { cerr << (char *) ex << endl;
  }
\end{code}
    \cfunction{int}{plThrow}{}
Used in the PREDICATE() wrapper to pass the exception to Prolog.  See
PL_raise_exeption().
    \cfunction{int}{cppThrow}{}
Used by PlQuery::next_solution() to refine a generic \class{PlException}
representing a specific class of Prolog exceptions to the corresponding
C++ exception class and finally then executes throw().  Thus, if a
\class{PlException} represents the term

\begin{quote}
\term{error}{\term{type_error}{Expected, Actual}, Context}
\end{quote}

PlException::cppThrow() throws a \class{PlTypeEror} exception. This
ensures consistency in the exception-class whether the exception is
generated by the C++-interface or returned by Prolog.

The following example illustrates this behaviour:

\begin{code}
PREDICATE(call_atom, 1)
{ try
  { return PlCall((char *)A1);
  } catch ( PlTypeError& ex )
  { cerr << "Type Error caugth in C++" << endl;
    cerr << "Message: \"" << (char *)ex << "\"" << endl;
    return false;
  }
}
\end{code}

\end{description}


\subsection{The class PlTypeError}
\label{sec:cpp-pl-type-error}

A \jargon{type error} expresses that a term does not satisfy the
expected basic Prolog type.

\begin{description}
    \constructor{PlTypeError}{const char *expected, const PlTerm \&actual}
Creates an ISO standard Prolog error term expressing the
\arg{expected} type and \arg{actual} term that does not satisfy this
type.
\end{description}


\subsection{The class PlDomainError}
\label{sec:cpp-pl-domain-error}

A \jargon{domain error} expresses that a term satisfies the basic
Prolog type expected, but is unacceptable to the restricted domain
expected by some operation.  For example, the standard Prolog open/3
call expect an \const{io_mode} (read, write, append, ...). If an integer
is provided, this is a \jargon{type error}, if an atom other than one
of the defined io-modes is provided it is a \jargon{domain error}.

\begin{description}
    \constructor{PlDomainError}{const char *expected, const PlTerm \&actual}
Creates an ISO standard Prolog error term expressing a the
\arg{expected} domain and the \arg{actual} term found.
\end{description}


\section{Embedded applications}
\label{sec:cpp-embedding}

Most of the above assumes Prolog is `in charge' of the application and
C++ is used to add functionality to Prolog, either for accessing
external resources or for performance reasons.  In some applications,
there is a \jargon{main-program} and we want to use Prolog as a
\jargon{logic server}.  For these applications, the class
\class{PlEngine} has been defined.

Only a single instance of this class can exist in a process.  When used
in a multi-threading application, only one thread at a time may have
a running query on this engine.  Applications should ensure this using
proper locking techniques.%
    \footnote{For Unix, there is a multi-threaded version of SWI-Prolog.
	      In this version each thread can create and destroy a
	      thread-engine. There is currently no C++ interface defined
	      to access this functionality, though ---of course--- you
	      can use the C-functions.}

\begin{description}
    \constructor{PlEngine}{int argc, char **argv}
Initialises the Prolog engine.  The application should make sure to
pass \exam{argv[0]} from its main function, which is needed in the
Unix version to find the running executable.  See PL_initialise()
for details.
    \constructor{PlEngine}{char *argv0}
Simple constructure using the main constructor with the specified
argument for \exam{argv[0]}.
    \destructor{PlEngine}
Calls PL_cleanup() to destroy all data created by the Prolog engine.
\end{description}

\Secref{pltail} has a simple example using this class.


\section{Considerations}
\label{sec:cpp-considerations}

\subsection{The C++ versus the C interface}
\label{sec:cpp-vs-c}

Not all functionality of the C-interface is provided, but as
\class{PlTerm} and \ctype{term_t} are essentially the same thing with
type-conversion between the two (using get_term_t()), this interface
can be freely mixed with the functions defined for plain C.

Using this interface rather than the plain C-interface requires a little
more resources. More term-references are wasted (but reclaimed on return
to Prolog or using \class{PlFrame}). Use of some intermediate types
(\ctype{functor_t} etc.) is not supported in the current interface,
causing more hash-table lookups. This could be fixed, at the price of
slighly complicating the interface.


\subsection{Static linking and embedding}
\label{sec:cpp-linking}

The mechanisms outlined in this document can be used for static linking
with the SWI-Prolog kernel using \manref{swipl-ld}{1}. In general the
C++ linker should be used to deal with the C++ runtime libraries and
global constructors.

\subsection{Status and compiler versions}
\label{sec:cpp-status}

The current interface is entirely defined in the \fileext{h} file using
inlined code.  This approach has a few advantages: as no C++ code is in
the Prolog kernel, different C++ compilers with different name-mangling
schemas can cooperate smoothly.

Also, changes to the header file have no consequences to binary
compatibility with the SWI-Prolog kernel. This makes it possible to have
different versions of the header file with few compatibility
consequences.

\section{Conclusions}				\label{sec:conclusions}
\label{sec:cpp-conclusions}

In this document, we presented a high-level interface to Prolog
exploiting automatic type-conversion and exception-handling defined in
C++.

Programming using this interface is much more natural and requires only
little extra resources in terms of time and memory.

Especially the smooth integration between C++ and Prolog exceptions
reduce the coding effort for type checking and reporting in foreign
predicates.

\printindex

\end{document}
