<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>A C++ interface to SWI-Prolog</TITLE><STYLE type="text/css">
/* Style sheet for SWI-Prolog latex2html
*/

dd.defbody
{ margin-bottom: 1em;
}

dt.pubdef
{ background-color: #c5e1ff;
}

pre.code
{ margin-left: 1.5em;
margin-right: 1.5em;
border: 1px dotted;
padding-top: 5px;
padding-left: 5px;
padding-bottom: 5px;
background-color: #f8f8f8;
}

div.navigate
{ text-align: center;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
}

div.title
{ text-align: center;
padding-bottom: 1em;
font-size: 200%;
font-weight: bold;
}

div.author
{ text-align: center;
font-style: italic;
}

div.abstract
{ margin-top: 2em;
background-color: #f0f0f0;
border: 1px dotted;
padding: 5px;
margin-left: 10%; margin-right:10%;
}

div.abstract-title
{ text-align: center;
padding: 5px;
font-size: 120%;
font-weight: bold;
}

div.toc-h1
{ font-size: 200%;
font-weight: bold;
}

div.toc-h2
{ font-size: 120%;
font-weight: bold;
margin-left: 2em;
}

div.toc-h3
{ font-size: 100%;
font-weight: bold;
margin-left: 4em;
}

div.toc-h4
{ font-size: 100%;
margin-left: 6em;
}

span.sec-nr
{ 
}

span.sec-title
{ 
}

span.pred-ext
{ font-weight: bold;
}

span.pred-tag
{ float: right;
font-size: 80%;
font-style: italic;
color: #202020;
}

/* Footnotes */

sup.fn { color: blue; text-decoration: underline; }
span.fn-text { display: none; }
sup.fn span {display: none;}
sup:hover span 
{ display: block !important;
position: absolute; top: auto; left: auto; width: 80%;
color: #000; background: white;
border: 2px solid;
padding: 5px; margin: 10px; z-index: 100;
font-size: smaller;
}
</STYLE>
</HEAD>
<BODY BGCOLOR="white">

<P>
<DIV class="title">A C++ interface to SWI-Prolog</DIV>
<DIV class="author">Jan Wielemaker <BR>
SWI, <BR>
University of Amsterdam <BR>
The Netherlands <BR>
E-mail: <A class="url" href="mailto:jan@swi.psy.uva.nl">jan@swi.psy.uva.nl</A></DIV>
<DIV class="abstract">
<DIV class="abstract-title">Abstract</DIV> This document describes a C++ 
interface to SWI-Prolog. SWI-Prolog could be used with C++ for a very 
long time, but only by calling the extern "C" functions of the 
C-interface. The interface described herein provides a true C++ layer 
around the C-interface for much more concise and natural programming 
from C++. The interface deals with automatic type-conversion to and from 
native C data-types, transparent mapping of exceptions, making queries 
to Prolog and registering foreign predicates.
</DIV>

<H1><A NAME="document-contents">Table of Contents</A></H1>

<DIV class="toc">
<DIV class="toc-h2"><A class="sec" href="#sec:1"><SPAN class="sec-nr">1</SPAN> <SPAN class="sec-title">Introduction</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:2"><SPAN class="sec-nr">2</SPAN> <SPAN class="sec-title">Overview</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:3"><SPAN class="sec-nr">3</SPAN> <SPAN class="sec-title">Examples</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.1"><SPAN class="sec-nr">3.1</SPAN> <SPAN class="sec-title">Hello(World)</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.2"><SPAN class="sec-nr">3.2</SPAN> <SPAN class="sec-title">Adding 
numbers</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:3.3"><SPAN class="sec-nr">3.3</SPAN> <SPAN class="sec-title">Average 
of solutions</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:4"><SPAN class="sec-nr">4</SPAN> <SPAN class="sec-title">The 
class PlTerm</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.1"><SPAN class="sec-nr">4.1</SPAN> <SPAN class="sec-title">Constructors</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.2"><SPAN class="sec-nr">4.2</SPAN> <SPAN class="sec-title">Casting 
PlTerm to native C-types</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.3"><SPAN class="sec-nr">4.3</SPAN> <SPAN class="sec-title">Unification</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.4"><SPAN class="sec-nr">4.4</SPAN> <SPAN class="sec-title">Comparison</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.5"><SPAN class="sec-nr">4.5</SPAN> <SPAN class="sec-title">Analysing 
compound terms</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.6"><SPAN class="sec-nr">4.6</SPAN> <SPAN class="sec-title">Miscellaneous</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.7"><SPAN class="sec-nr">4.7</SPAN> <SPAN class="sec-title">The 
class PlString</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.8"><SPAN class="sec-nr">4.8</SPAN> <SPAN class="sec-title">The 
class PlCodeList</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.9"><SPAN class="sec-nr">4.9</SPAN> <SPAN class="sec-title">The 
class PlCharList</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.10"><SPAN class="sec-nr">4.10</SPAN> <SPAN class="sec-title">The 
class PlCompound</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:4.11"><SPAN class="sec-nr">4.11</SPAN> <SPAN class="sec-title">The 
class PlTail</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:5"><SPAN class="sec-nr">5</SPAN> <SPAN class="sec-title">The 
class PlTermv</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:6"><SPAN class="sec-nr">6</SPAN> <SPAN class="sec-title">Supporting 
Prolog constants</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:7"><SPAN class="sec-nr">7</SPAN> <SPAN class="sec-title">The 
class PlRegister</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:8"><SPAN class="sec-nr">8</SPAN> <SPAN class="sec-title">The 
class PlQuery</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:8.1"><SPAN class="sec-nr">8.1</SPAN> <SPAN class="sec-title">The 
class PlFrame</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:9"><SPAN class="sec-nr">9</SPAN> <SPAN class="sec-title">The 
PREDICATE macro</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:9.1"><SPAN class="sec-nr">9.1</SPAN> <SPAN class="sec-title">Controlling 
the Prolog destination module</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:10"><SPAN class="sec-nr">10</SPAN> <SPAN class="sec-title">Exceptions</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:10.1"><SPAN class="sec-nr">10.1</SPAN> <SPAN class="sec-title">The 
class PlException</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:10.2"><SPAN class="sec-nr">10.2</SPAN> <SPAN class="sec-title">The 
class PlTypeError</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:10.3"><SPAN class="sec-nr">10.3</SPAN> <SPAN class="sec-title">The 
class PlDomainError</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:11"><SPAN class="sec-nr">11</SPAN> <SPAN class="sec-title">Embedded 
applications</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:12"><SPAN class="sec-nr">12</SPAN> <SPAN class="sec-title">Considerations</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:12.1"><SPAN class="sec-nr">12.1</SPAN> <SPAN class="sec-title">The 
C++ versus the C interface</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:12.2"><SPAN class="sec-nr">12.2</SPAN> <SPAN class="sec-title">Static 
linking and embedding</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:12.3"><SPAN class="sec-nr">12.3</SPAN> <SPAN class="sec-title">Status 
and compiler versions</SPAN></A></DIV>
<DIV class="toc-h3"><A class="sec" href="#sec:12.4"><SPAN class="sec-nr">12.4</SPAN> <SPAN class="sec-title">Limitations</SPAN></A></DIV>
<DIV class="toc-h2"><A class="sec" href="#sec:13"><SPAN class="sec-nr">13</SPAN> <SPAN class="sec-title">Conclusions</SPAN></A></DIV>
</DIV>

<H2><A NAME="sec:1"><SPAN class="sec-nr">1</SPAN> <SPAN class="sec-title">Introduction</SPAN></A></H2>

<P>C++ provides a number of features that make it possible to define a 
much more natural and concise interface to dynamically typed languages 
than plain C does. Using programmable type-conversion (<EM>casting</EM>), 
native data-types can be translated automatically into appropriate 
Prolog types, automatic destructors can be used to deal with most of the 
cleanup required and C++ exception handling can be used to map Prolog 
exceptions and interface conversion errors to C++ exceptions, which are 
automatically mapped to Prolog exceptions as control is turned back to 
Prolog.

<H3>Competing interfaces</H3>

<P>Volker Wysk has defined an alternative C++ mapping based on templates 
and compatible to the STL framework. See
<A class="url" href="http://www.volker-wysk.de/swiprolog-c++/index.html">http://www.volker-wysk.de/swiprolog-c++/index.html</A>.

<H3>Acknowledgements</H3>

<P>I would like to thank Anjo Anjewierden for comments on the 
definition, implementation and documentation of this package.

<H2><A NAME="sec:2"><SPAN class="sec-nr">2</SPAN> <SPAN class="sec-title">Overview</SPAN></A></H2>

<P>The most useful area for exploiting C++ features is type-conversion. 
Prolog variables are dynamically typed and all information is passed 
around using the C-interface type <B><CODE>term_t</CODE></B>. In C++, <B><CODE>term_t</CODE></B> 
is embedded in the <EM>lightweight</EM> class <A class="" href="#class:PlTerm">PlTerm</A>. 
Constructors and operator definitions provide flexible operations and 
integration with important C-types (<B><CODE>char *</CODE></B>, <B><CODE>long</CODE></B> 
and
<B><CODE>double</CODE></B>).

<P>The list below summarises the classes defined in the C++ interface.

<DL>
<DT><A NAME="class:PlTerm"><STRONG>PlTerm</STRONG></A></DT>
<DD class="defbody">
Generic Prolog term. Provides constructors and operators for conversion 
to native C-data and type-checking.
</DD>
<DT><A NAME="class:PlString"><STRONG>PlString</STRONG></A></DT>
<DD class="defbody">
Subclass of <A class="" href="#class:PlTerm">PlTerm</A> with 
constructors for building Prolog string objects.
</DD>
<DT><A NAME="class:PlCodeList"><STRONG>PlCodeList</STRONG></A></DT>
<DD class="defbody">
Subclass of <A class="" href="#class:PlTerm">PlTerm</A> with 
constructors for building Prolog lists of ASCII values.
</DD>
<DT><A NAME="class:PlCharList"><STRONG>PlCharList</STRONG></A></DT>
<DD class="defbody">
Subclass of <A class="" href="#class:PlTerm">PlTerm</A> with 
constructors for building Prolog lists of one-character atoms (as <A NAME="idx:atomchars2:1"></A><SPAN class="pred-ext">atom_chars/2</SPAN>).
</DD>
<DT><A NAME="class:PlCompound"><STRONG>PlCompound</STRONG></A></DT>
<DD class="defbody">
Subclass of <A class="" href="#class:PlTerm">PlTerm</A> with 
constructors for building compound terms.
</DD>
<DT><A NAME="class:PlTail"><STRONG>PlTail</STRONG></A></DT>
<DD class="defbody">
SubClass of <A class="" href="#class:PlTerm">PlTerm</A> for building and 
analysing Prolog lists.
</DD>
<DT><A NAME="class:PlTermv"><STRONG>PlTermv</STRONG></A></DT>
<DD class="defbody">
Vector of Prolog terms. See PL_new_term_refs(). the <CODE>[]</CODE> 
operator is overloaded to access elements in this vector. <A class="" href="#class:PlTermv">PlTermv</A> 
is used to build complex terms and provide argument-lists to Prolog 
goals.
</DD>
<DT><A NAME="class:PlException"><STRONG>PlException</STRONG></A></DT>
<DD class="defbody">
Subclass of <A class="" href="#class:PlTerm">PlTerm</A> representing a 
Prolog exception. Provides methods for the Prolog communication and 
mapping to human-readable text representation.
</DD>
<DT><A NAME="class:PlTypeError"><STRONG>PlTypeError</STRONG></A></DT>
<DD class="defbody">
Subclass of <A class="" href="#class:PlException">PlException</A> for 
representing a Prolog
<CODE>type_error</CODE> exception.
</DD>
<DT><A NAME="class:PlDomainError"><STRONG>PlDomainError</STRONG></A></DT>
<DD class="defbody">
Subclass of <A class="" href="#class:PlException">PlException</A> for 
representing a Prolog
<CODE>domain_error</CODE> exception.
</DD>
<DT><A NAME="class:PlAtom"><STRONG>PlAtom</STRONG></A></DT>
<DD class="defbody">
Allow for manipulating atoms in their internal Prolog representation for 
fast comparison.
</DD>
<DT><A NAME="class:PlQuery"><STRONG>PlQuery</STRONG></A></DT>
<DD class="defbody">
Represents opening and enumerating the solutions to a Prolog query.
</DD>
<DT><A NAME="class:PlFrame"><STRONG>PlFrame</STRONG></A></DT>
<DD class="defbody">
This utility-class can be used to discard unused term-references as well 
as to do `<EM>data-backtracking</EM>'.
</DD>
<DT><A NAME="class:PlEngine"><STRONG>PlEngine</STRONG></A></DT>
<DD class="defbody">
This class is used in <EM>embedded</EM> applications (applications where 
the main control is held in C++). It provides creation and destruction 
of the Prolog environment.
</DD>
<DT><A NAME="class:PlRegister"><STRONG>PlRegister</STRONG></A></DT>
<DD class="defbody">
The encapsulation of PL_register_foreign() is defined to be able to use 
C++ global constructors for registering foreign predicates.
</DD>
</DL>

<P>The required C(++) function header and registration of a predicate is 
arranged through a macro called <B>PREDICATE()</B>.

<H2><A NAME="sec:3"><SPAN class="sec-nr">3</SPAN> <SPAN class="sec-title">Examples</SPAN></A></H2>

<P>Before going into a detailed description of the C++ classes we 
present a few examples illustrating the `feel' of the interface.

<H3><A NAME="sec:3.1"><SPAN class="sec-nr">3.1</SPAN> <SPAN class="sec-title">Hello(World)</SPAN></A></H3>

<P>This very simple example shows the basic definition of the predicate
<A NAME="idx:hello1:2"></A><SPAN class="pred-ext">hello/1</SPAN> and how 
a Prolog argument is converted to C-data:

<PRE class="code">
PREDICATE(hello, 1)
{ cout &lt;&lt; "Hello " &lt;&lt; (char *)A1 &lt;&lt; endl;

  return TRUE;
}
</PRE>

<P>The arguments to PREDICATE() are the name and arity of the predicate. 
The macros A&lt;<VAR>n</VAR>&gt; provide access to the predicate 
arguments by position and are of the type <A class="" href="#class:PlTerm">PlTerm</A>. 
Casting a <A class="" href="#class:PlTerm">PlTerm</A> to a
<B><CODE>char *</CODE></B> provides the natural type-conversion for most 
Prolog data-types, using the output of <A NAME="idx:write1:3"></A><SPAN class="pred-ext">write/1</SPAN> 
otherwise:

<PRE class="code">
?- hello(world).
Hello world

Yes
?- hello(X)
Hello _G170

X = _G170
</PRE>

<H3><A NAME="sec:3.2"><SPAN class="sec-nr">3.2</SPAN> <SPAN class="sec-title">Adding 
numbers</SPAN></A></H3>

<P>This example shows arithmetic using the C++ interface, including 
unification, type-checking and conversion. The predicate <A NAME="idx:add3:4"></A><SPAN class="pred-ext">add/3</SPAN> 
adds the two first arguments and unifies the last with the result.

<PRE class="code">
PREDICATE(add, 3)
{ return A3 = (long)A1 + (long)A2;
}
</PRE>

<P>Casting a <A class="" href="#class:PlTerm">PlTerm</A> to a <B><CODE>long</CODE></B> 
performs a PL_get_long() and throws a C++ exception if the Prolog 
argument is not a Prolog integer or float that can be converted without 
loss to a <B><CODE>long</CODE></B>. The
<CODE>=</CODE> operator of <A class="" href="#class:PlTerm">PlTerm</A> 
is defined to perform unification and returns <CODE>TRUE</CODE> or <CODE>FALSE</CODE> 
depending on the result.

<PRE class="code">
?- add(1, 2, X).

X = 3.
?- add(a, 2, X).
[ERROR: Type error: `integer' expected, found `a']
   Exception: (  7) add(a, 2, _G197) ?
</PRE>

<H3><A NAME="sec:3.3"><SPAN class="sec-nr">3.3</SPAN> <SPAN class="sec-title">Average 
of solutions</SPAN></A></H3>

<P>This example is a bit harder. The predicate <A NAME="idx:average3:5"></A><SPAN class="pred-ext">average/3</SPAN> 
is defined to take the template average(+Var, :Goal, -Average) , where <VAR>Goal</VAR> 
binds <VAR>Var</VAR> and will unify <VAR>Average</VAR> with average of 
the (integer) results.

<P><A class="" href="#class:PlQuery">PlQuery</A> takes the name of a 
predicate and the goal-argument vector as arguments. From this 
information it deduces the arity and locates the predicate. the 
member-function next_solution() yields
<CODE>TRUE</CODE> if there was a solution and <CODE>FALSE</CODE> 
otherwise. If the goal yielded a Prolog exception it is mapped into a 
C++ exception.

<PRE class="code">
PREDICATE(average, 3)
{ long sum = 0;
  long n = 0;

  PlQuery q("call", PlTermv(A2));
  while( q.next_solution() )
  { sum += (long)A1;
    n++;
  }
  return A3 = (double)sum/(double)n;
}
</PRE>

<H2><A NAME="sec:4"><SPAN class="sec-nr">4</SPAN> <SPAN class="sec-title">The 
class PlTerm</SPAN></A></H2>

<P>As we have seen from the examples, the <A class="" href="#class:PlTerm">PlTerm</A> 
class plays a central role in conversion and operating on Prolog data. 
This section provides complete documentation of this class.

<H3><A NAME="sec:4.1"><SPAN class="sec-nr">4.1</SPAN> <SPAN class="sec-title">Constructors</SPAN></A></H3>

<DL>
<DT><STRONG>PlTerm :: PlTerm</STRONG>(<VAR></VAR>)</DT>
<DD class="defbody">
Creates a new initialised term (holding a Prolog variable).
</DD>
<DT><STRONG>PlTerm :: PlTerm</STRONG>(<VAR>term_t t</VAR>)</DT>
<DD class="defbody">
Converts between the C-interface and the C++ interface by turning the 
term-reference into an instance of <A class="" href="#class:PlTerm">PlTerm</A>. 
Note that, being a lightweight class, this is a no-op at the 
machine-level!
</DD>
<DT><STRONG>PlTerm :: PlTerm</STRONG>(<VAR>const char *text</VAR>)</DT>
<DD class="defbody">
Creates a term-references holding a Prolog atom representing <VAR>text</VAR>.
</DD>
<DT><STRONG>PlTerm :: PlTerm</STRONG>(<VAR>const PlAtom &amp;atom</VAR>)</DT>
<DD class="defbody">
Creates a term-references holding a Prolog atom from an atom-handle.
</DD>
<DT><STRONG>PlTerm :: PlTerm</STRONG>(<VAR>long n</VAR>)</DT>
<DD class="defbody">
Creates a term-references holding a Prolog integer representing <VAR>n</VAR>.
</DD>
<DT><STRONG>PlTerm :: PlTerm</STRONG>(<VAR>double f</VAR>)</DT>
<DD class="defbody">
Creates a term-references holding a Prolog float representing <VAR>f</VAR>.
</DD>
<DT><STRONG>PlTerm :: PlTerm</STRONG>(<VAR>void *ptr</VAR>)</DT>
<DD class="defbody">
Creates a term-references holding a Prolog pointer. A pointer is 
represented in Prolog as a mangled integer. The mangling is designed to 
make most pointers fit into a <EM>tagged-integer</EM>. Any valid pointer 
can be represented. This mechanism can be used to represent pointers to 
C++ objects in Prolog. Please note that `myclass' should define 
conversion to and from <B><CODE>void *</CODE></B>.

<PRE class="code">
PREDICATE(make_my_object, 1)
{ myclass *myobj = new myclass();
  
  return A1 = (void *)myobj;
}

PREDICATE(free_my_object, 1)
{ myclass *myobj = (void *)A1;
  
  delete(myobj);
  return TRUE;
}
</PRE>

<P></DD>
</DL>

<H3><A NAME="sec:4.2"><SPAN class="sec-nr">4.2</SPAN> <SPAN class="sec-title">Casting 
PlTerm to native C-types</SPAN></A></H3>

<P><A class="" href="#class:PlTerm">PlTerm</A> can be casted to the 
following types:

<DL>
<DT><STRONG>PlTerm ::operator term_t</STRONG>(<VAR>void</VAR>)</DT>
<DD class="defbody">
This cast is used for integration with the C-interface primitives.
</DD>
<DT><STRONG>PlTerm ::operator long</STRONG>(<VAR>void</VAR>)</DT>
<DD class="defbody">
Yields a <B><CODE>long</CODE></B> if the <A class="" href="#class:PlTerm">PlTerm</A> 
is a Prolog integer or float that can be converted without loss to a 
long. throws a
<CODE>type_error</CODE> exception otherwise.
</DD>
<DT><STRONG>PlTerm ::operator int</STRONG>(<VAR>void</VAR>)</DT>
<DD class="defbody">
Same as for <B><CODE>long</CODE></B>, but might represent fewer bits.
</DD>
<DT><STRONG>PlTerm ::operator double</STRONG>(<VAR>void</VAR>)</DT>
<DD class="defbody">
Yields the value as a C double if <A class="" href="#class:PlTerm">PlTerm</A> 
represents a Prolog integer or float.
</DD>
<DT><STRONG>PlTerm ::operator char *</STRONG>(<VAR>void</VAR>)</DT>
<DD class="defbody">
Converts the Prolog argument using PL_get_chars() using the flags
<CODE>CVT_ALL|CVT_WRITE|BUF_RING</CODE>, which implies Prolog atoms and 
strings are converted to the represented text. All other data is handed 
to <A NAME="idx:write1:6"></A><SPAN class="pred-ext">write/1</SPAN>. If 
the text is static in Prolog, a direct pointer to the string is 
returned. Otherwise the text is saved in a ring of 16 buffers and must 
be copied to avoid overwriting.
</DD>
<DT><STRONG>PlTerm ::operator void *</STRONG>(<VAR>void</VAR>)</DT>
<DD class="defbody">
Extracts pointer value from a term. The term should have been created by 
PlTerm::PlTerm(void*).
</DD>
</DL>

<H3><A NAME="sec:4.3"><SPAN class="sec-nr">4.3</SPAN> <SPAN class="sec-title">Unification</SPAN></A></H3>

<DL>
<DT class="pubdef"><A NAME="PlTerm::operator=()"><VAR>int</VAR> <STRONG>PlTerm::operator 
=</STRONG>(<VAR>Type</VAR>)</A></DT>
<DD class="defbody">
The operator <CODE>=</CODE> is defined for the <VAR>Types</VAR> <A class="" href="#class:PlTerm">PlTerm</A>,
<B><CODE>long</CODE></B>, <B><CODE>double</CODE></B>, <B><CODE>char *</CODE></B> 
and <A class="" href="#class:PlAtom">PlAtom</A>. It performs Prolog 
unification and returns <CODE>TRUE</CODE> if successful and
<CODE>FALSE</CODE> otherwise.

<P>The boolean return-value leads to somewhat unconventional-looking 
code as normally, assignment returns the value assigned in C. 
Unification however is fundamentally different to assignment as it can 
succeed or fail. Here is a common example.

<PRE class="code">
PREDICATE(hostname, 1)
{ char buf[32];

  if ( gethostname(buf, sizeof(buf)) == 0 )
    return A1 = buf;

  return FALSE;
}
</PRE>

<P></DD>
</DL>

<H3><A NAME="sec:4.4"><SPAN class="sec-nr">4.4</SPAN> <SPAN class="sec-title">Comparison</SPAN></A></H3>

<DL>
<DT class="pubdef"><A NAME="PlTerm::operator==()"><VAR>int</VAR> <STRONG>PlTerm::operator 
==</STRONG>(<VAR>const PlTerm &amp;t</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator!=()"><VAR>int</VAR> <STRONG>PlTerm::operator 
!=</STRONG>(<VAR>const PlTerm &amp;t</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator <()"><VAR>int</VAR> <STRONG>PlTerm::operator <VAR>&lt;</VAR></STRONG>(<VAR>const 
PlTerm &amp;t</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator >()"><VAR>int</VAR> <STRONG>PlTerm::operator <VAR>&gt;</VAR></STRONG>(<VAR>const 
PlTerm &amp;t</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator <=()"><VAR>int</VAR> <STRONG>PlTerm::operator <VAR>&lt;=</VAR></STRONG>(<VAR>const 
PlTerm &amp;t</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator >=()"><VAR>int</VAR> <STRONG>PlTerm::operator <VAR>&gt;=</VAR></STRONG>(<VAR>const 
PlTerm &amp;t</VAR>)</A></DT>
<DD class="defbody">
Compare the instance with <VAR>t</VAR> and return the result according 
to the Prolog defined <EM>standard order of terms</EM>.
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator==()"><VAR>int</VAR> <STRONG>PlTerm::operator 
==</STRONG>(<VAR>long num</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator!=()"><VAR>int</VAR> <STRONG>PlTerm::operator 
!=</STRONG>(<VAR>long num</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator <()"><VAR>int</VAR> <STRONG>PlTerm::operator <VAR>&lt;</VAR></STRONG>(<VAR>long 
num</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator >()"><VAR>int</VAR> <STRONG>PlTerm::operator <VAR>&gt;</VAR></STRONG>(<VAR>long 
num</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator <=()"><VAR>int</VAR> <STRONG>PlTerm::operator <VAR>&lt;=</VAR></STRONG>(<VAR>long 
num</VAR>)</A></DT>
<DD class="defbody">
</DD>
<DT class="pubdef"><A NAME="PlTerm::operator >=()"><VAR>int</VAR> <STRONG>PlTerm::operator <VAR>&gt;=</VAR></STRONG>(<VAR>long 
num</VAR>)</A></DT>
<DD class="defbody">
Convert <A class="" href="#class:PlTerm">PlTerm</A> to a <B><CODE>long</CODE></B> 
and perform standard C-comparison between the two long integers. If <A class="" href="#class:PlTerm">PlTerm</A> 
cannot be converted a <CODE>type_error</CODE> is raised.</DD>
<DT class="pubdef"><A NAME="PlTerm::operator==()"><VAR>int</VAR> <STRONG>PlTerm::operator 
==</STRONG>(<VAR>const char *</VAR>)</A></DT>
<DD class="defbody">
Yields <CODE>TRUE</CODE> if the <A class="" href="#class:PlTerm">PlTerm</A> 
is an atom or string representing the same text as the argument, <CODE>FALSE</CODE> 
if the conversion was successful, but the strings are not equal and an
<CODE>type_error</CODE> exception if the conversion failed.
</DD>
</DL>

<P>Below are some typical examples. See <A class="sec" href="#sec:6">section 
6</A> for direct manipulation of atoms in their internal representation.

<P>
<CENTER>
<TABLE BORDER=2 FRAME=box RULES=groups>
<TR VALIGN=top><TD><TT>A1 <VAR>&lt;</VAR> 0</TT></TD><TD>Test <VAR>A1</VAR> 
to hold a Prolog integer or float that can be transformed lossless to an 
integer less than zero. </TD></TR>
<TR VALIGN=top><TD><TT>A1 <VAR>&lt;</VAR> PlTerm(0)</TT></TD><TD><VAR>A1</VAR> 
is before the term `0' in the `standard order of terms'. This means that 
if <VAR>A1</VAR> represents an atom, this test yields <CODE>TRUE</CODE>. </TD></TR>
<TR VALIGN=top><TD><TT>A1 == PlCompound("a(1)")</TT></TD><TD>Test <VAR>A1</VAR> 
to represent the term
<CODE>a(1)</CODE>. </TD></TR>
<TR VALIGN=top><TD><TT>A1 == "now"</TT></TD><TD>Test <VAR>A1</VAR> to be 
an atom or string holding the text ``now''. </TD></TR>
</TABLE>

</CENTER>

<H3><A NAME="sec:4.5"><SPAN class="sec-nr">4.5</SPAN> <SPAN class="sec-title">Analysing 
compound terms</SPAN></A></H3>

<P>Compound terms can be viewed as an array of terms with a name and 
arity (length). This view is expressed by overloading the <CODE>[]</CODE> 
operator.

<P>A <CODE>type_error</CODE> is raised if the argument is not compound 
and a
<CODE>domain_error</CODE> if the index is out of range.

<P>In addition, the following functions are defined:

<DL>
<DT class="pubdef"><A NAME="PlTerm::operator\[]()"><VAR>PlTerm</VAR> <STRONG>PlTerm::operator[]</STRONG>(<VAR>int 
arg</VAR>)</A></DT>
<DD class="defbody">
If the <A class="" href="#class:PlTerm">PlTerm</A> is a compound term 
and <VAR>arg</VAR> is between 1 and the arity of the term, return a new <A class="" href="#class:PlTerm">PlTerm</A> 
representing the arg-th argument of the term. If <A class="" href="#class:PlTerm">PlTerm</A> 
is not compound, a
<CODE>type_error</CODE> is raised. Id <VAR>arg</VAR> is out of range, a
<CODE>domain_error</CODE> is raised. Please note the counting from 1 
which is consistent to Prolog's <A NAME="idx:arg3:7"></A><SPAN class="pred-ext">arg/3</SPAN> 
predicate, but inconsistent to C's normal view on an array. See also 
class <A class="" href="#class:PlCompound">PlCompound</A>. The following 
example tests <VAR>x</VAR> to represent a term with first-argument an 
atom or string equal to <CODE>gnat</CODE>.

<PRE class="code">
   ...,
   if ( x[1] == "gnat" )
     ...
</PRE>

</DD>
<DT class="pubdef"><A NAME="PlTerm::name()"><VAR>const char *</VAR> <STRONG>PlTerm::name</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Return a <B><CODE>const char *</CODE></B> holding the name of the 
functor of the compound term. Raises a <CODE>type_error</CODE> if the 
argument is not compound.
</DD>
<DT class="pubdef"><A NAME="PlTerm::arity()"><VAR>int</VAR> <STRONG>PlTerm::arity</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Returns the arity of the compound term. Raises a <CODE>type_error</CODE> 
if the argument is not compound.
</DD>
</DL>

<H3><A NAME="sec:4.6"><SPAN class="sec-nr">4.6</SPAN> <SPAN class="sec-title">Miscellaneous</SPAN></A></H3>

<DL>
<DT class="pubdef"><A NAME="PlTerm::type()"><VAR>int</VAR> <STRONG>PlTerm::type</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Yields the actual type of the term as PL_term_type(). Return values are
<CODE>PL_VARIABLE</CODE>, <CODE>PL_FLOAT</CODE>, <CODE>PL_INTEGER</CODE>,
<CODE>PL_ATOM</CODE>, <CODE>PL_STRING</CODE> or <CODE>PL_TERM</CODE>
</DD>
</DL>

<P>To avoid very confusing combinations of constructors and therefore 
possible undesirable effects a number of subclasses of <A class="" href="#class:PlTerm">PlTerm</A> 
have been defined that provide constructors for creating special Prolog 
terms. These subclasses are defined below.

<H3><A NAME="sec:4.7"><SPAN class="sec-nr">4.7</SPAN> <SPAN class="sec-title">The 
class PlString</SPAN></A></H3>

<P>A SWI-Prolog string represents a byte-string on the global stack. 
It's lifetime is the same as for compound terms and other data living on 
the global stack. Strings are not only a compound representation of text 
that is garbage-collected, but as they can contain 0-bytes, they can be 
used to contain arbitrary C-data structures.

<DL>
<DT><STRONG>PlString :: PlString</STRONG>(<VAR>const char *text</VAR>)</DT>
<DD class="defbody">
Create a SWI-Prolog string object from a 0-terminated C-string. The
<VAR>text</VAR> is copied.
</DD>
<DT><STRONG>PlString :: PlString</STRONG>(<VAR>const char *text, int len</VAR>)</DT>
<DD class="defbody">
Create a SWI-Prolog string object from a C-string with specified length. 
The <VAR>text</VAR> may contain 0-characters and is copied.
</DD>
</DL>

<H3><A NAME="sec:4.8"><SPAN class="sec-nr">4.8</SPAN> <SPAN class="sec-title">The 
class PlCodeList</SPAN></A></H3>

<DL>
<DT><STRONG>PlCodeList :: PlCodeList</STRONG>(<VAR>const char *text</VAR>)</DT>
<DD class="defbody">
Create a Prolog list of ASCII codes from a 0-terminated C-string.
</DD>
</DL>

<H3><A NAME="sec:4.9"><SPAN class="sec-nr">4.9</SPAN> <SPAN class="sec-title">The 
class PlCharList</SPAN></A></H3>

<P>Character lists are compliant to Prolog's <A NAME="idx:atomchars2:8"></A><SPAN class="pred-ext">atom_chars/2</SPAN> 
predicate.

<DL>
<DT><STRONG>PlCharList :: PlCharList</STRONG>(<VAR>const char *text</VAR>)</DT>
<DD class="defbody">
Create a Prolog list of one-character atoms from a 0-terminated 
C-string.
</DD>
</DL>

<H3><A NAME="sec:4.10"><SPAN class="sec-nr">4.10</SPAN> <SPAN class="sec-title">The 
class PlCompound</SPAN></A></H3>

<DL>
<DT><STRONG>PlCompound :: PlCompound</STRONG>(<VAR>const char *text</VAR>)</DT>
<DD class="defbody">
Create a term by parsing (as <A NAME="idx:read1:9"></A><SPAN class="pred-ext">read/1</SPAN>) 
the <VAR>text</VAR>. If the <VAR>text</VAR> is not valid Prolog syntax, 
a <CODE>syntax_error</CODE> exception is raised. Otherwise a new 
term-reference holding the parsed text is created.
</DD>
<DT><STRONG>PlCompound :: PlCompound</STRONG>(<VAR>const char *functor, 
PlTermv args</VAR>)</DT>
<DD class="defbody">
Create a compound term with the given name from the given vector of 
arguments. See <A class="" href="#class:PlTermv">PlTermv</A> for 
details. The example below creates the Prolog term <CODE>hello(world)</CODE>.

<PRE class="code">
PlCompound("hello", PlTermv("world"))
</PRE>

<P></DD>
</DL>

<H3><A NAME="sec:4.11"><SPAN class="sec-nr">4.11</SPAN> <SPAN class="sec-title">The 
class PlTail</SPAN></A></H3>

<A NAME="sec:pltail"></A>

<P>The class <A class="" href="#class:PlTail">PlTail</A> is both for 
analysing and constructing lists. It is called <A class="" href="#class:PlTail">PlTail</A> 
as enumeration-steps make the term-reference follow the `tail' of the 
list.

<DL>
<DT><STRONG>PlTail :: PlTail</STRONG>(<VAR>PlTerm list</VAR>)</DT>
<DD class="defbody">
A <A class="" href="#class:PlTail">PlTail</A> is created by making a new 
term-reference pointing to the same object. As <A class="" href="#class:PlTail">PlTail</A> 
is used to enumerate or build a Prolog list, the initial <VAR>list</VAR> 
term-reference keeps pointing to the head of the list.
</DD>
<DT class="pubdef"><A NAME="PlTail::append()"><VAR>int</VAR> <STRONG>PlTail::append</STRONG>(<VAR>const 
PlTerm &amp;element</VAR>)</A></DT>
<DD class="defbody">
Appends <VAR>element</VAR> to the list and make the <A class="" href="#class:PlTail">PlTail</A> 
reference point to the new variable tail. If <VAR>A</VAR> is a variable, 
and this function is called on it using the argument <CODE>"gnat"</CODE>, 
a list of the form <CODE>[gnat|B]</CODE> is created and the <A class="" href="#class:PlTail">PlTail</A> 
object now points to the new variable <VAR>B</VAR>.

<P>This function returns <CODE>TRUE</CODE> if the unification succeeded 
and
<CODE>FALSE</CODE> otherwise. No exceptions are generated.

<P>The example below translates the main() argument vector to Prolog and 
calls the prolog predicate <A NAME="idx:entry1:10"></A><SPAN class="pred-ext">entry/1</SPAN> 
with it.

<PRE class="code">
int
main(int argc, char **argv)
{ PlEngine e(argv[0]);
  PlTermv av(1);
  PlTail l(av[0]);

  for(int i=0; i&lt;argc; i++)
    l.append(argv[i]);
  l.close();

  PlQuery q("entry", av);
  return q.next_solution() ? 0 : 1;
}
</PRE>

</DD>
<DT class="pubdef"><A NAME="PlTail::close()"><VAR>int</VAR> <STRONG>PlTail::close</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Unifies the term with <CODE>[]</CODE> and returns the result of the 
unification.
</DD>
<DT class="pubdef"><A NAME="PlTail::next()"><VAR>int</VAR> <STRONG>PlTail::next</STRONG>(<VAR>PlTerm &amp;t</VAR>)</A></DT>
<DD class="defbody">
Bind <VAR>t</VAR> to the next element of the list <A class="" href="#class:PlTail">PlTail</A> 
and advance
<A class="" href="#class:PlTail">PlTail</A>. Returns <CODE>TRUE</CODE> 
on success and <CODE>FALSE</CODE> if
<A class="" href="#class:PlTail">PlTail</A> represents the empty list. 
If <A class="" href="#class:PlTail">PlTail</A> is neither a list nor the 
empty list, a <CODE>type_error</CODE> is thrown. The example below 
prints the elements of a list.

<PRE class="code">
PREDICATE(write_list, 1)
{ PlTail tail(A1);
  PlTerm e;

  while(tail.next(e))
    cout &lt;&lt; (char *)e &lt;&lt; endl;

  return TRUE;
}
</PRE>

<P></DD>
</DL>

<H2><A NAME="sec:5"><SPAN class="sec-nr">5</SPAN> <SPAN class="sec-title">The 
class PlTermv</SPAN></A></H2>

<P>The class <A class="" href="#class:PlTermv">PlTermv</A> represents an 
array of term-references. This type is used to pass the arguments to a 
foreignly defined predicate, construct compound terms (see <B>PlTerm::PlTerm(const 
char *name, PlTermv arguments)</B>) and to create queries (see <A class="" href="#class:PlQuery">PlQuery</A>).

<P>The only useful member function is the overloading of <CODE>[]</CODE>, 
providing (0-based) access to the elements. Range checking is performed 
and raises a <CODE>domain_error</CODE> exception.

<P>The constructors for this class are below.

<DL>
<DT><STRONG>PlTermv :: PlTermv</STRONG>(<VAR>int size</VAR>)</DT>
<DD class="defbody">
Create a new array of term-references, all holding variables.
</DD>
<DT><STRONG>PlTermv :: PlTermv</STRONG>(<VAR>int size, term_t t0</VAR>)</DT>
<DD class="defbody">
Convert a C-interface defined term-array into an instance.
</DD>
<DT><STRONG>PlTermv :: PlTermv</STRONG>(<VAR>PlTerm ...</VAR>)</DT>
<DD class="defbody">
Create a vector from 1 to 5 initialising arguments. For example:

<PRE class="code">
load_file(const char *file)
{ return PlCall("compile", PlTermv(file));
}
</PRE>

<P>If the vector has to contain more than 5 elements, the following 
construction should be used:

<PRE class="code">
{ PlTermv av(10);

  av[0] = "hello";
  ...
</PRE>

<P></DD>
</DL>

<H2><A NAME="sec:6"><SPAN class="sec-nr">6</SPAN> <SPAN class="sec-title">Supporting 
Prolog constants</SPAN></A></H2>

<P>Both for quick comparison as for quick building of lists of atoms, it 
is desirable to provide access to Prolog's atom-table, mapping handles 
to unique string-constants. If the handles of two atoms are different it 
is guaranteed they represent different text strings.

<P>Suppose we want to test whether a term represents a certain atom, 
this interface presents a large number of alternatives:

<H3>Direct comparision to char *</H3>

<P>Example:

<PRE class="code">
PREDICATE(test, 1)
{ if ( A1 == "read" )
    ...;
</PRE>

<P>This writes easily and is the preferred method is performance is not 
critical and only a few comparisons have to be made. It validates
<VAR>A1</VAR> to be a term-reference representing text (atom, string, 
integer or float) extracts the represented text and uses strcmp() to 
match the strings.

<H3>Direct comparision to PlAtom</H3>

<A NAME="sec:dirplatom"></A>

<P>Example:

<PRE class="code">
static PlAtom ATOM_read("read");

PREDICATE(test, 1)
{ if ( A1 == ATOM_read )
    ...;
</PRE>

<P>This case raises a <CODE>type_error</CODE> if <VAR>A1</VAR> is not an 
atom. Otherwise it extacts the atom-handle and compares it to the 
atom-handle of the global <A class="" href="#class:PlAtom">PlAtom</A> 
object. This approach is faster and provides more strict type-checking.

<H3>Extraction of the atom and comparison to PlAtom</H3>

<P>Example:

<PRE class="code">
static PlAtom ATOM_read("read");

PREDICATE(test, 1)
{ PlAtom a1(A1);

  if ( a1 == ATOM_read )
    ...;
</PRE>

<P>This approach is basically the same as <A class="sec" href="#sec:6">section 
6</A>, but in nested if-then-else the extraction of the atom from the 
term is done only once.

<H3>Extraction of the atom and comparison to char *</H3>

<P>Example:

<PRE class="code">
PREDICATE(test, 1)
{ PlAtom a1(A1);

  if ( a1 == "read" )
    ...;
</PRE>

<P>This approach extracts the atom once and for each test extracts the 
represented string from the atom and compares it. It avoids the need for 
global atom constructors.

<DL>
<DT><STRONG>PlAtom :: PlAtom</STRONG>(<VAR>atom_t handle</VAR>)</DT>
<DD class="defbody">
Create from C-interface atom handle. Used internally and for integration 
with the C-interface.
</DD>
<DT><STRONG>PlAtom :: PlAtom</STRONG>(<VAR>const char *text</VAR>)</DT>
<DD class="defbody">
Create from a string. The <VAR>text</VAR> is copied if a new atom is 
created.
</DD>
<DT><STRONG>PlAtom :: PlAtom</STRONG>(<VAR>const PlTerm &amp;t</VAR>)</DT>
<DD class="defbody">
If <VAR>t</VAR> represents an atom, the new instance represents this 
atom. Otherwise a <CODE>type_error</CODE> is thrown.
</DD>
<DT class="pubdef"><A NAME="PlAtom::operator==()"><VAR>int</VAR> <STRONG>PlAtom::operator 
==</STRONG>(<VAR>const char *text</VAR>)</A></DT>
<DD class="defbody">
Yields <CODE>TRUE</CODE> if the atom represents <VAR>text</VAR>, <CODE>FALSE</CODE> 
otherwise. Performs a strcmp() for this.
</DD>
<DT class="pubdef"><A NAME="PlAtom::operator==()"><VAR>int</VAR> <STRONG>PlAtom::operator 
==</STRONG>(<VAR>const PlAtom &amp;a</VAR>)</A></DT>
<DD class="defbody">
Compares the two atom-handles, returning <CODE>TRUE</CODE> or
<CODE>FALSE</CODE>.
</DD>
</DL>

<H2><A NAME="sec:7"><SPAN class="sec-nr">7</SPAN> <SPAN class="sec-title">The 
class PlRegister</SPAN></A></H2>

<P>This class encapsulates PL_register_foreign(). It is defined as a 
class rather then a function to exploit the C++ <EM>global constructor</EM> 
feature. This class provides a constructor to deal with the PREDICATE() 
way of defining foreign predicates as well as constructors to deal with 
more conventional foreign predicate definitions.

<DL>
<DT><STRONG>PlRegister :: PlRegister</STRONG>(<VAR>const char *module, 
const char *name, int arity, foreign_t (f)(term_t t0, int a, control_t 
ctx)</VAR>)</DT>
<DD class="defbody">
Register <VAR>f</VAR> as a the implementation of the foreign predicate
&lt;<VAR>name</VAR>&gt;/&lt;<VAR>arity</VAR>&gt;. This interface uses 
the <CODE>PL_FA_VARARGS</CODE> calling convention, where the argument 
list of the predicate is passed using an array of <B><CODE>term_t</CODE></B> 
objects as returned by PL_new_term_refs(). This interface poses no 
limits on the arity of the predicate and is faster, especially for a 
large number of arguments.
</DD>
<DT><STRONG>PlRegister :: PlRegister</STRONG>(<VAR>const char *module, 
const char *name, foreign_t (*f)(PlTerm a0, ... )</VAR>)</DT>
<DD class="defbody">
Registers functions for use with the traditional calling conventional, 
where each positional argument to the predicate is passed as an argument 
to the function <VAR>f</VAR>. This can be used to define functions as 
predicates similar to what is used in the C-interface:

<PRE class="code">
static foreign_t
pl_hello(PlTerm a1)
{ ...
}

PlRegister x_hello_1(NULL, "hello", 1, pl_hello);
</PRE>

<P>This construct is currently supported upto 3 arguments.
</DD>
</DL>

<H2><A NAME="sec:8"><SPAN class="sec-nr">8</SPAN> <SPAN class="sec-title">The 
class PlQuery</SPAN></A></H2>

<P>This class encapsulates the call-backs onto Prolog.

<DL>
<DT><STRONG>PlQuery :: PlQuery</STRONG>(<VAR>const char *name, const 
PlTermv &amp;av</VAR>)</DT>
<DD class="defbody">
Create a query where <VAR>name</VAR> defines the name of the predicate 
and
<VAR>av</VAR> the argument vector. The arity is deduced from <VAR>av</VAR>. 
The predicate is located in the Prolog module <CODE>user</CODE>.
</DD>
<DT><STRONG>PlQuery :: PlQuery</STRONG>(<VAR>const char *module, const 
char *name, const PlTermv &amp;av</VAR>)</DT>
<DD class="defbody">
Same, but performs the predicate lookup in the indicated module.
</DD>
<DT class="pubdef"><A NAME="PlQuery::next_solution()"><VAR>int</VAR> <STRONG>PlQuery::next_solution</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Provide the next solution to the query. Yields <CODE>TRUE</CODE> if 
successful and <CODE>FALSE</CODE> if there are no (more) solutions. 
Prolog exceptions are mapped to C++ exceptions.
</DD>
</DL>

<P>Below is an example listing the currently defined Prolog modules to 
the terminal.

<PRE class="code">
PREDICATE(list_modules, 0)
{ PlTermv av(1);

  PlQuery q("current_module", av);
  while( q.next_solution() )
    cout &lt;&lt; (char *)av[0] &lt;&lt; endl;

  return TRUE;
}
</PRE>

<P>In addition to the above, the following functions have been defined.

<DL>
<DT class="pubdef"><A NAME="PlCall()"><VAR>int</VAR> <STRONG>PlCall</STRONG>(<VAR>const 
char *predicate, const PlTermv &amp;av</VAR>)</A></DT>
<DD class="defbody">
Creates a <A class="" href="#class:PlQuery">PlQuery</A> from the 
arguments generates the first next_solution() and destroys the query. 
Returns the result of next_solution() or an exception.
</DD>
<DT class="pubdef"><A NAME="PlCall()"><VAR>int</VAR> <STRONG>PlCall</STRONG>(<VAR>const 
char *module, const char *predicate, const PlTermv &amp;av</VAR>)</A></DT>
<DD class="defbody">
Same, locating the predicate in the named module.
</DD>
<DT class="pubdef"><A NAME="PlCall()"><VAR>int</VAR> <STRONG>PlCall</STRONG>(<VAR>const 
char *goal</VAR>)</A></DT>
<DD class="defbody">
Translates <VAR>goal</VAR> into a term and calls this term as the other 
PlCall() variations. Especially suitable for simple goals such as making 
Prolog load a file.
</DD>
</DL>

<H3><A NAME="sec:8.1"><SPAN class="sec-nr">8.1</SPAN> <SPAN class="sec-title">The 
class PlFrame</SPAN></A></H3>

<P>The class <A class="" href="#class:PlFrame">PlFrame</A> provides an 
interface to discard unused term-references as well as rewinding 
unifications (<EM>data-backtracking</EM>). Reclaiming unused 
term-references is automatically performed after a call to a C++-defined 
predicate has finished and returns control to Prolog. In this scenario <A class="" href="#class:PlFrame">PlFrame</A> 
is rarely of any use. This class comes into play if the toplevel program 
is defined in C++ and calls Prolog multiple times. Setting up arguments 
to a query requires term-references and using <A class="" href="#class:PlFrame">PlFrame</A> 
is the only way to reclaim them.

<DL>
<DT><STRONG>PlFrame :: PlFrame</STRONG>(<VAR></VAR>)</DT>
<DD class="defbody">
Creating an instance of this class marks all term-references created 
afterwards to be valid only in the scope of this instance.
</DD>
<DT><STRONG>~ PlFrame</STRONG>(<VAR></VAR>)</DT>
<DD class="defbody">
Reclaims all term-references created after constructing the instance.
</DD>
<DT class="pubdef"><A NAME="PlFrame::rewind()"><VAR>void</VAR> <STRONG>PlFrame::rewind</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Discards all term-references <B>and</B> global-stack data created as 
well as undoing all unifications after the instance was created.
</DD>
</DL>

<P><A NAME="idx:assert:11"></A>A typical use for <A class="" href="#class:PlFrame">PlFrame</A> 
is the definition of C++ functions that call Prolog and may be called 
repeatedly from C++. Consider the definition of assertWord(), adding a 
fact to <A NAME="idx:word1:12"></A><SPAN class="pred-ext">word/1</SPAN>:

<PRE class="code">
void
assertWord(const char *word)
{ PlFrame fr;
  PlTermv av(1);

  av[1] = PlCompound("word", PlTermv(word));
  PlQuery q("assert", av);
  q.next_solution();
}
</PRE>

<P>This example shows the most sensible use of <A class="" href="#class:PlFrame">PlFrame</A> 
if it is used in the context of a foreign predicate. The predicate's 
thruth-value is the same as for the Prolog unification (=/2), but has no 
side effects. In Prolog one would use double negation to achieve this.

<PRE class="code">
PREDICATE(can_unify, 2)
{ PlFrame fr;

  int rval = (A1=A2);
  fr.rewind();
  return rval;
}
</PRE>

<H2><A NAME="sec:9"><SPAN class="sec-nr">9</SPAN> <SPAN class="sec-title">The 
PREDICATE macro</SPAN></A></H2>

<P>The PREDICATE macro is there to make your code look nice, taking care 
of the interface to the C-defined SWI-Prolog kernel as well as mapping 
exceptions. Using the macro

<PRE class="code">
PREDICATE(hello, 1)
</PRE>

<P>is the same as writing:

<PRE class="code">
static foreign_t pl_hello__1(PlTermv _av);

static foreign_t
_pl_hello__1(term_t t0, int arity, control_t ctx)
{ try
  { return pl_hello__1(PlTermv(1, t0));
  } catch ( PlTerm &amp;ex )
  { return ex.raise();
  }
}

static PlRegister _x_hello__1("hello", 1, _pl_hello__1);

static foreign_t
pl_hello__1(PlTermv _av)
</PRE>

<P>The first function converts the parameters passed from the Prolog 
kernel to a <A class="" href="#class:PlTermv">PlTermv</A> instance and 
maps exceptions raised in the body to Prolog exceptions. The <A class="" href="#class:PlRegister">PlRegister</A> 
global constructor registers the predicate. Finally, the function header 
for the implementation is created.

<H3><A NAME="sec:9.1"><SPAN class="sec-nr">9.1</SPAN> <SPAN class="sec-title">Controlling 
the Prolog destination module</SPAN></A></H3>

<P>With no special precautions, the predicates are defined into the 
module from which <A NAME="idx:loadforeignlibrary1:13"></A><SPAN class="pred-ext">load_foreign_library/1</SPAN> 
was called, or in the module
<CODE>user</CODE> if there is no Prolog context from which to deduce the 
module such as while linking the extension statically with the Prolog 
kernel.

<P>Alternatively, <EM>before</EM> loading the SWI-Prolog include file, 
the macro PROLOG_MODULE may be defined to a string containing the name 
of the destination module. A module name may only contain 
alpha-numerical characters (letters, digits, _). See the example below:

<PRE class="code">
#define PROLOG_MODULE "math"
#include &lt;SWI-Prolog.h&gt;
#include &lt;math.h&gt;

PREDICATE(pi, 1)
{ A1 = M_PI;
}
</PRE>

<PRE class="code">
?- math:pi(X).

X = 3.14159
</PRE>

<H2><A NAME="sec:10"><SPAN class="sec-nr">10</SPAN> <SPAN class="sec-title">Exceptions</SPAN></A></H2>

<P>Prolog exceptions are mapped to C++ exceptions using the subclass
<A class="" href="#class:PlException">PlException</A> of <A class="" href="#class:PlTerm">PlTerm</A> 
to represent the Prolog exception term. All type-conversion functions of 
the interface raise Prolog-compliant exceptions, providing decent 
error-handling support at no extra work for the programmer.

<P>For some commonly used exceptions, subclasses of <A class="" href="#class:PlException">PlException</A> 
have been created to exploit both their constructors for easy creation 
of these exceptions as well as selective trapping in C++. Currently, 
these are <B>PlTypeEror</B> and <A class="" href="#class:PlDomainError">PlDomainError</A>.

<P>To throw an exception, create an instance of <A class="" href="#class:PlException">PlException</A> 
and use throw() or PlException::cppThrow(). The latter refines the C++ 
exception class according to the represented Prolog exception before 
calling throw().

<PRE class="code">
  char *data = "users";

  throw PlException(PlCompound("no_database", PlTerm(data)));
</PRE>

<H3><A NAME="sec:10.1"><SPAN class="sec-nr">10.1</SPAN> <SPAN class="sec-title">The 
class PlException</SPAN></A></H3>

<P>This subclass of <A class="" href="#class:PlTerm">PlTerm</A> is used 
to represent exceptions. Currently defined methods are:

<DL>
<DT><STRONG>PlException :: PlException</STRONG>(<VAR>const PlTerm &amp;t</VAR>)</DT>
<DD class="defbody">
Create an exception from a general Prolog term. This is provides the 
interface for throwing any Prolog terms as an exception.
</DD>
<DT><STRONG>PlException ::operator char *</STRONG>(<VAR>void</VAR>)</DT>
<DD class="defbody">
The exception is translated into a message as produced by
<A NAME="idx:printmessage2:14"></A><SPAN class="pred-ext">print_message/2</SPAN>. 
The character data is stored in a ring. Example:

<PRE class="code">
  ...;
  try
  { PlCall("consult(load)");
  } catch ( PlException &amp;ex )
  { cerr &lt;&lt; (char *) ex &lt;&lt; endl;
  }
</PRE>

</DD>
<DT class="pubdef"><A NAME="plThrow()"><VAR>int</VAR> <STRONG>plThrow</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Used in the PREDICATE() wrapper to pass the exception to Prolog. See 
PL_raise_exeption().
</DD>
<DT class="pubdef"><A NAME="cppThrow()"><VAR>int</VAR> <STRONG>cppThrow</STRONG>(<VAR></VAR>)</A></DT>
<DD class="defbody">
Used by PlQuery::next_solution() to refine a generic <A class="" href="#class:PlException">PlException</A> 
representing a specific class of Prolog exceptions to the corresponding 
C++ exception class and finally then executes throw(). Thus, if a
<A class="" href="#class:PlException">PlException</A> represents the 
term
<BLOCKQUOTE>
<CODE>error(<CODE>type_error(Expected, Actual)</CODE>, Context)</CODE>
</BLOCKQUOTE>

<P>PlException::cppThrow() throws a <B>PlTypeEror</B> exception. This 
ensures consistency in the exception-class whether the exception is 
generated by the C++-interface or returned by Prolog.

<P>The following example illustrates this behaviour:

<PRE class="code">
PREDICATE(call_atom, 1)
{ try
  { return PlCall((char *)A1);
  } catch ( PlTypeError &amp;ex )
  { cerr &lt;&lt; "Type Error caugth in C++" &lt;&lt; endl;
    cerr &lt;&lt; "Message: \"" &lt;&lt; (char *)ex &lt;&lt; "\"" &lt;&lt; endl;
    return FALSE;
  }
}
</PRE>

<P></DD>
</DL>

<H3><A NAME="sec:10.2"><SPAN class="sec-nr">10.2</SPAN> <SPAN class="sec-title">The 
class PlTypeError</SPAN></A></H3>

<P>A <EM>type error</EM> expresses that a term does not satisfy the 
expected basic Prolog type.

<DL>
<DT><STRONG>PlTypeError :: PlTypeError</STRONG>(<VAR>const char 
*expected, const PlTerm &amp;actual</VAR>)</DT>
<DD class="defbody">
Creates an ISO standard Prolog error term expressing the
<VAR>expected</VAR> type and <VAR>actual</VAR> term that does not 
satisfy this type.
</DD>
</DL>

<H3><A NAME="sec:10.3"><SPAN class="sec-nr">10.3</SPAN> <SPAN class="sec-title">The 
class PlDomainError</SPAN></A></H3>

<P>A <EM>domain error</EM> expresses that a term satisfies the basic 
Prolog type expected, but is unacceptable to the restricted domain 
expected by some operation. For example, the standard Prolog <A NAME="idx:open3:15"></A><SPAN class="pred-ext">open/3</SPAN> 
call expect an <CODE>io_mode</CODE> (read, write, append, ...). If an 
integer is provided, this is a <EM>type error</EM>, if an atom other 
than one of the defined io-modes is provided it is a <EM>domain error</EM>.

<DL>
<DT><STRONG>PlDomainError :: PlDomainError</STRONG>(<VAR>const char 
*expected, const PlTerm &amp;actual</VAR>)</DT>
<DD class="defbody">
Creates an ISO standard Prolog error term expressing a the
<VAR>expected</VAR> domain and the <VAR>actual</VAR> term found.
</DD>
</DL>

<H2><A NAME="sec:11"><SPAN class="sec-nr">11</SPAN> <SPAN class="sec-title">Embedded 
applications</SPAN></A></H2>

<P>Most of the above assumes Prolog is `in charge' of the application 
and C++ is used to add functionality to Prolog, either for accessing 
external resources or for performance reasons. In some applications, 
there is a <EM>main-program</EM> and we want to use Prolog as a
<EM>logic server</EM>. For these applications, the class
<A class="" href="#class:PlEngine">PlEngine</A> has been defined.

<P>Only a single instance of this class can exist in a process. When 
used in a multi-threading application, only one thread at a time may 
have a running query on this engine. Applications should ensure this 
using proper locking techniques.<SUP class="fn">1<SPAN class="fn-text">For 
Unix, there is a multi-threaded version of SWI-Prolog. In this version 
each thread can create and destroy a thread-engine. There is currently 
no C++ interface defined to access this functionality, though ---of 
course--- you can use the C-functions.</SPAN></SUP>

<DL>
<DT><STRONG>PlEngine :: PlEngine</STRONG>(<VAR>int argc, char **argv</VAR>)</DT>
<DD class="defbody">
Initialises the Prolog engine. The application should make sure to pass <CODE>argv[0]</CODE> 
from its main function, which is needed in the Unix version to find the 
running executable. See PL_initialise() for details.
</DD>
<DT><STRONG>PlEngine :: PlEngine</STRONG>(<VAR>char *argv0</VAR>)</DT>
<DD class="defbody">
Simple constructure using the main constructor with the specified 
argument for <CODE>argv[0]</CODE>.
</DD>
<DT><STRONG>~ PlEngine</STRONG>(<VAR></VAR>)</DT>
<DD class="defbody">
Calls PL_cleanup() to destroy all data created by the Prolog engine.
</DD>
</DL>

<P><A class="sec" href="#sec:4.11">Section 4.11</A> has a simple example 
using this class.

<H2><A NAME="sec:12"><SPAN class="sec-nr">12</SPAN> <SPAN class="sec-title">Considerations</SPAN></A></H2>

<H3><A NAME="sec:12.1"><SPAN class="sec-nr">12.1</SPAN> <SPAN class="sec-title">The 
C++ versus the C interface</SPAN></A></H3>

<P>Not all functionality of the C-interface is provided, but as
<A class="" href="#class:PlTerm">PlTerm</A> and <B><CODE>term_t</CODE></B> 
are essentially the same thing with automatic type-conversion between 
the two, this interface can be freely mixed with the functions defined 
for plain C.

<P>Using this interface rather than the plain C-interface requires a 
little more resources. More term-references are wasted (but reclaimed on 
return to Prolog or using <A class="" href="#class:PlFrame">PlFrame</A>). 
Use of some intermediate types (<B><CODE>functor_t</CODE></B> etc.) is 
not supported in the current interface, causing more hash-table lookups. 
This could be fixed, at the price of slighly complicating the interface.

<H3><A NAME="sec:12.2"><SPAN class="sec-nr">12.2</SPAN> <SPAN class="sec-title">Static 
linking and embedding</SPAN></A></H3>

<P>The mechanisms outlined in this document can be used for static 
linking with the SWI-Prolog kernel using <STRONG>plld</STRONG>(1). In 
general the C++ linker should be used to deal with the C++ runtime 
libraries and global constructors. As of SWI-Prolog 3.2.9, 
PL_register_foreign() can be called <EM>before</EM> PL_initialise(), 
which is required to handle the calls from the global <A class="" href="#class:PlRegister">PlRegister</A> 
calls.

<H3><A NAME="sec:12.3"><SPAN class="sec-nr">12.3</SPAN> <SPAN class="sec-title">Status 
and compiler versions</SPAN></A></H3>

<P>The current interface is entirely defined in the <CODE>.h</CODE> file 
using inlined code. This approach has a few advantages: as no C++ code 
is in the Prolog kernel, different C++ compilers with different 
name-mangling schemas can cooperate smoothly.

<P>Also, changes to the header file have no consequences to binary 
compatibility with the SWI-Prolog kernel. This makes it possible to have 
different versions of the header file with few compatibility 
consequences. If the interface stabilises we will consider options to 
share more code.

<H3><A NAME="sec:12.4"><SPAN class="sec-nr">12.4</SPAN> <SPAN class="sec-title">Limitations</SPAN></A></H3>

<P>Currently, the following limitations are recognised:

<P>
<UL>
<LI><I>Predicate naming</I><BR>
Using the PREDICATE() macro, only predicates with a name that is valid 
as part of a C-symbol can be defined. Notably this makes the definition 
of predicates with names consisting of <EM>symbol characters</EM> 
impossible.
<LI><I>Non-deterministic predicates</I><BR>
The current interface does not provide for foreign-defined 
non-deterministic predicates. It would not be hard to add this.
</UL>

<H2><A NAME="sec:13"><SPAN class="sec-nr">13</SPAN> <SPAN class="sec-title">Conclusions</SPAN></A></H2>

<A NAME="sec:conclusions"></A>

<P>In this document, we presented a high-level interface to Prolog 
exploying automatic type-conversion and exception-handling defined in 
C++.

<P>Programming using this interface is much more natural and requires 
only little extra resources in terms of time and memory.

<P>Especially the smooth integration between C++ and Prolog exceptions 
reduce the coding effort for type checking and reporting in foreign 
predicates.

<H1><A NAME="document-index">Index</A></H1>

<DL>
<DT><STRONG>A</STRONG></DT>
<DD>
</DD>
<DT>add/3</DT>
<DD>
<A class="idx" href="#idx:add3:4">3.2</A></DD>
<DT>arg/3</DT>
<DD>
<A class="idx" href="#idx:arg3:7">4.5</A></DD>
<DT>assert</DT>
<DD>
<A class="idx" href="#idx:assert:11">8.1</A></DD>
<DT>atom_chars/2</DT>
<DD>
<A class="idx" href="#idx:atomchars2:1">2</A> <A class="idx" href="#idx:atomchars2:8">4.9</A></DD>
<DT>average/3</DT>
<DD>
<A class="idx" href="#idx:average3:5">3.3</A></DD>
<DT><STRONG>C</STRONG></DT>
<DD>
</DD>
<DT><A class="idx" href="#cppThrow()">cppThrow()</A></DT>
<DD>
</DD>
<DT><STRONG>E</STRONG></DT>
<DD>
</DD>
<DT>entry/1</DT>
<DD>
<A class="idx" href="#idx:entry1:10">4.11</A></DD>
<DT><STRONG>H</STRONG></DT>
<DD>
</DD>
<DT>hello/1</DT>
<DD>
<A class="idx" href="#idx:hello1:2">3.1</A></DD>
<DT><STRONG>L</STRONG></DT>
<DD>
</DD>
<DT>load_foreign_library/1</DT>
<DD>
<A class="idx" href="#idx:loadforeignlibrary1:13">9.1</A></DD>
<DT><STRONG>O</STRONG></DT>
<DD>
</DD>
<DT>open/3</DT>
<DD>
<A class="idx" href="#idx:open3:15">10.3</A></DD>
<DT><STRONG>P</STRONG></DT>
<DD>
</DD>
<DT>PlAtom</DT>
<DD>
<A class="sec" href="#sec:4.3">4.3</A> <A class="sec" href="#sec:6">6</A></DD>
<DT><A class="idx" href="#PlAtom::operator==()">PlAtom::operator==()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlCall()">PlCall()</A></DT>
<DD>
</DD>
<DT>PlCompound</DT>
<DD>
<A class="sec" href="#sec:4.5">4.5</A></DD>
<DT>PlDomainError</DT>
<DD>
<A class="sec" href="#sec:10">10</A></DD>
<DT>PlEngine</DT>
<DD>
<A class="sec" href="#sec:11">11</A></DD>
<DT>PlException</DT>
<DD>
<A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:10">10</A> <A class="sec" href="#sec:10">10</A> <A class="sec" href="#sec:10">10</A> <A class="sec" href="#sec:10.1">10.1</A> <A class="sec" href="#sec:10.1">10.1</A></DD>
<DT>PlFrame</DT>
<DD>
<A class="sec" href="#sec:8.1">8.1</A> <A class="sec" href="#sec:8.1">8.1</A> <A class="sec" href="#sec:8.1">8.1</A> <A class="sec" href="#sec:8.1">8.1</A> <A class="sec" href="#sec:8.1">8.1</A> <A class="sec" href="#sec:12.1">12.1</A></DD>
<DT><A class="idx" href="#PlFrame::rewind()">PlFrame::rewind()</A></DT>
<DD>
</DD>
<DT>PlQuery</DT>
<DD>
<A class="sec" href="#sec:3.3">3.3</A> <A class="sec" href="#sec:5">5</A> <A class="sec" href="#sec:8">8</A></DD>
<DT><A class="idx" href="#PlQuery::next_solution()">PlQuery::next_solution()</A></DT>
<DD>
</DD>
<DT>PlRegister</DT>
<DD>
<A class="sec" href="#sec:9">9</A> <A class="sec" href="#sec:12.2">12.2</A></DD>
<DT>PlTail</DT>
<DD>
<A class="sec" href="#sec:4.11">4.11</A> <A class="sec" href="#sec:4.11">4.11</A> <A class="sec" href="#sec:4.11">4.11</A> <A class="sec" href="#sec:4.11">4.11</A> <A class="sec" href="#sec:4.11">4.11</A> <A class="sec" href="#sec:4.11">4.11</A> <A class="sec" href="#sec:4.11">4.11</A> <A class="sec" href="#sec:4.11">4.11</A> <A class="sec" href="#sec:4.11">4.11</A> <A class="sec" href="#sec:4.11">4.11</A></DD>
<DT><A class="idx" href="#PlTail::append()">PlTail::append()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTail::close()">PlTail::close()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTail::next()">PlTail::next()</A></DT>
<DD>
</DD>
<DT>PlTerm</DT>
<DD>
<A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:3.1">3.1</A> <A class="sec" href="#sec:3.1">3.1</A> <A class="sec" href="#sec:3.2">3.2</A> <A class="sec" href="#sec:3.2">3.2</A> <A class="sec" href="#sec:4">4</A> <A class="sec" href="#sec:4.1">4.1</A> <A class="sec" href="#sec:4.2">4.2</A> <A class="sec" href="#sec:4.2">4.2</A> <A class="sec" href="#sec:4.2">4.2</A> <A class="sec" href="#sec:4.3">4.3</A> <A class="sec" href="#sec:4.4">4.4</A> <A class="sec" href="#sec:4.4">4.4</A> <A class="sec" href="#sec:4.4">4.4</A> <A class="sec" href="#sec:4.5">4.5</A> <A class="sec" href="#sec:4.5">4.5</A> <A class="sec" href="#sec:4.5">4.5</A> <A class="sec" href="#sec:4.6">4.6</A> <A class="sec" href="#sec:10">10</A> <A class="sec" href="#sec:10.1">10.1</A> <A class="sec" href="#sec:12.1">12.1</A></DD>
<DT><A class="idx" href="#PlTerm::arity()">PlTerm::arity()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::name()">PlTerm::name()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::operator <()">PlTerm::operator &lt;()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::operator <=()">PlTerm::operator &lt;=()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::operator >()">PlTerm::operator &gt;()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::operator >=()">PlTerm::operator &gt;=()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::operator!=()">PlTerm::operator!=()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::operator=()">PlTerm::operator=()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::operator==()">PlTerm::operator==()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::operator\[]()">PlTerm::operator[]()</A></DT>
<DD>
</DD>
<DT><A class="idx" href="#PlTerm::type()">PlTerm::type()</A></DT>
<DD>
</DD>
<DT>PlTermv</DT>
<DD>
<A class="sec" href="#sec:2">2</A> <A class="sec" href="#sec:4.10">4.10</A> <A class="sec" href="#sec:5">5</A> <A class="sec" href="#sec:9">9</A></DD>
<DT><A class="idx" href="#plThrow()">plThrow()</A></DT>
<DD>
</DD>
<DT>PlTypeEror</DT>
<DD>
<A class="sec" href="#sec:10">10</A> <A class="sec" href="#sec:10.1">10.1</A></DD>
<DT>print_message/2</DT>
<DD>
<A class="idx" href="#idx:printmessage2:14">10.1</A></DD>
<DT><STRONG>R</STRONG></DT>
<DD>
</DD>
<DT>read/1</DT>
<DD>
<A class="idx" href="#idx:read1:9">4.10</A></DD>
<DT><STRONG>W</STRONG></DT>
<DD>
</DD>
<DT>word/1</DT>
<DD>
<A class="idx" href="#idx:word1:12">8.1</A></DD>
<DT>write/1</DT>
<DD>
<A class="idx" href="#idx:write1:3">3.1</A> <A class="idx" href="#idx:write1:6">4.2</A></DD>
</DL>

</BODY></HTML>